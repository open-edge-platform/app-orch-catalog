// SPDX-FileCopyrightText: (C) 2023 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: catalog/v3/service.proto

package catalogv3

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CatalogService_UploadCatalogEntities_FullMethodName        = "/catalog.v3.CatalogService/UploadCatalogEntities"
	CatalogService_CreateRegistry_FullMethodName               = "/catalog.v3.CatalogService/CreateRegistry"
	CatalogService_ListRegistries_FullMethodName               = "/catalog.v3.CatalogService/ListRegistries"
	CatalogService_GetRegistry_FullMethodName                  = "/catalog.v3.CatalogService/GetRegistry"
	CatalogService_UpdateRegistry_FullMethodName               = "/catalog.v3.CatalogService/UpdateRegistry"
	CatalogService_DeleteRegistry_FullMethodName               = "/catalog.v3.CatalogService/DeleteRegistry"
	CatalogService_WatchRegistries_FullMethodName              = "/catalog.v3.CatalogService/WatchRegistries"
	CatalogService_CreateDeploymentPackage_FullMethodName      = "/catalog.v3.CatalogService/CreateDeploymentPackage"
	CatalogService_ListDeploymentPackages_FullMethodName       = "/catalog.v3.CatalogService/ListDeploymentPackages"
	CatalogService_GetDeploymentPackage_FullMethodName         = "/catalog.v3.CatalogService/GetDeploymentPackage"
	CatalogService_GetDeploymentPackageVersions_FullMethodName = "/catalog.v3.CatalogService/GetDeploymentPackageVersions"
	CatalogService_UpdateDeploymentPackage_FullMethodName      = "/catalog.v3.CatalogService/UpdateDeploymentPackage"
	CatalogService_DeleteDeploymentPackage_FullMethodName      = "/catalog.v3.CatalogService/DeleteDeploymentPackage"
	CatalogService_WatchDeploymentPackages_FullMethodName      = "/catalog.v3.CatalogService/WatchDeploymentPackages"
	CatalogService_CreateApplication_FullMethodName            = "/catalog.v3.CatalogService/CreateApplication"
	CatalogService_ListApplications_FullMethodName             = "/catalog.v3.CatalogService/ListApplications"
	CatalogService_GetApplication_FullMethodName               = "/catalog.v3.CatalogService/GetApplication"
	CatalogService_GetApplicationReferenceCount_FullMethodName = "/catalog.v3.CatalogService/GetApplicationReferenceCount"
	CatalogService_GetApplicationVersions_FullMethodName       = "/catalog.v3.CatalogService/GetApplicationVersions"
	CatalogService_UpdateApplication_FullMethodName            = "/catalog.v3.CatalogService/UpdateApplication"
	CatalogService_DeleteApplication_FullMethodName            = "/catalog.v3.CatalogService/DeleteApplication"
	CatalogService_WatchApplications_FullMethodName            = "/catalog.v3.CatalogService/WatchApplications"
	CatalogService_CreateArtifact_FullMethodName               = "/catalog.v3.CatalogService/CreateArtifact"
	CatalogService_ListArtifacts_FullMethodName                = "/catalog.v3.CatalogService/ListArtifacts"
	CatalogService_GetArtifact_FullMethodName                  = "/catalog.v3.CatalogService/GetArtifact"
	CatalogService_UpdateArtifact_FullMethodName               = "/catalog.v3.CatalogService/UpdateArtifact"
	CatalogService_DeleteArtifact_FullMethodName               = "/catalog.v3.CatalogService/DeleteArtifact"
	CatalogService_WatchArtifacts_FullMethodName               = "/catalog.v3.CatalogService/WatchArtifacts"
)

// CatalogServiceClient is the client API for CatalogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CatalogService provides API to manage the inventory of applications, deployment packages, and other resources related
// to deployment of applications at the network edge.
//
// The principal resources managed by the application catalog service are as follows:
// - [Application](catalog.v3.Application) represents a Helm\* chart that can be deployed to one or more Kubernetes\* pods.
//
//   - [DeploymentPackage](catalog.v3.DeploymentPackage) represents a collection of applications (referenced by their name and a version) that are
//     deployed together. The package can define one or more deployment profiles that specify the individual application
//     profiles to be used when deploying each application. If applications need to be deployed in a particular order, the
//     package can also define any startup dependencies between its constituent applications as a set of dependency graph edges.
//
//   - [Registry](catalog.v3.Registry) represents a repository from which various artifacts, such as application Docker\* images or Helm charts,
//     can be retrieved. As such, registry entity holds information used for finding and accessing the represented repository.
//
//   - [Artifact](catalog.v3.Artifact) represents a binary artifact that can be used for various purposes, e.g. icon or thumbnail for UI display, or
//     auxiliary artifacts for integration with various platform services such as Grafana\* dashboard and similar. An artifact may be
//     used by multiple deployment packages.
//
// The API provides Create, Get, List, Update, Delete, and Watch operations for each of the above resources.
type CatalogServiceClient interface {
	// Allows uploading of a YAML file containing various application catalog entities. Multiple RPC invocations
	// tagged with the same upload session ID can be used to upload multiple files and to create or update several
	// catalog entities as a single transaction.
	UploadCatalogEntities(ctx context.Context, in *UploadCatalogEntitiesRequest, opts ...grpc.CallOption) (*UploadCatalogEntitiesResponse, error)
	// Creates a new registry.
	CreateRegistry(ctx context.Context, in *CreateRegistryRequest, opts ...grpc.CallOption) (*CreateRegistryResponse, error)
	// Gets a list of registries.
	ListRegistries(ctx context.Context, in *ListRegistriesRequest, opts ...grpc.CallOption) (*ListRegistriesResponse, error)
	// Gets a specific registry.
	GetRegistry(ctx context.Context, in *GetRegistryRequest, opts ...grpc.CallOption) (*GetRegistryResponse, error)
	// Updates a registry.
	UpdateRegistry(ctx context.Context, in *UpdateRegistryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes a registry.
	DeleteRegistry(ctx context.Context, in *DeleteRegistryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Watches inventory of registries for changes.
	WatchRegistries(ctx context.Context, in *WatchRegistriesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchRegistriesResponse], error)
	// Creates a new deployment package.
	CreateDeploymentPackage(ctx context.Context, in *CreateDeploymentPackageRequest, opts ...grpc.CallOption) (*CreateDeploymentPackageResponse, error)
	// Gets a list of deployment packages.
	ListDeploymentPackages(ctx context.Context, in *ListDeploymentPackagesRequest, opts ...grpc.CallOption) (*ListDeploymentPackagesResponse, error)
	// Gets a specific deployment package.
	GetDeploymentPackage(ctx context.Context, in *GetDeploymentPackageRequest, opts ...grpc.CallOption) (*GetDeploymentPackageResponse, error)
	// Gets all versions of a named deployment package.
	GetDeploymentPackageVersions(ctx context.Context, in *GetDeploymentPackageVersionsRequest, opts ...grpc.CallOption) (*GetDeploymentPackageVersionsResponse, error)
	// Updates a deployment package.
	UpdateDeploymentPackage(ctx context.Context, in *UpdateDeploymentPackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes a deployment package.
	DeleteDeploymentPackage(ctx context.Context, in *DeleteDeploymentPackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Watches inventory of deployment packages for changes.
	WatchDeploymentPackages(ctx context.Context, in *WatchDeploymentPackagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchDeploymentPackagesResponse], error)
	// Creates a new application.
	CreateApplication(ctx context.Context, in *CreateApplicationRequest, opts ...grpc.CallOption) (*CreateApplicationResponse, error)
	// Gets a list of applications.
	ListApplications(ctx context.Context, in *ListApplicationsRequest, opts ...grpc.CallOption) (*ListApplicationsResponse, error)
	// Gets a specific application.
	GetApplication(ctx context.Context, in *GetApplicationRequest, opts ...grpc.CallOption) (*GetApplicationResponse, error)
	// Gets application reference count - the number of deployment packages using this application.
	GetApplicationReferenceCount(ctx context.Context, in *GetApplicationReferenceCountRequest, opts ...grpc.CallOption) (*GetApplicationReferenceCountResponse, error)
	// Gets all versions of a named application.
	GetApplicationVersions(ctx context.Context, in *GetApplicationVersionsRequest, opts ...grpc.CallOption) (*GetApplicationVersionsResponse, error)
	// Updates an application.
	UpdateApplication(ctx context.Context, in *UpdateApplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes an application.
	DeleteApplication(ctx context.Context, in *DeleteApplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Watches inventory of applications for changes.
	WatchApplications(ctx context.Context, in *WatchApplicationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchApplicationsResponse], error)
	// Creates a new artifact.
	CreateArtifact(ctx context.Context, in *CreateArtifactRequest, opts ...grpc.CallOption) (*CreateArtifactResponse, error)
	// Gets a list of artifacts.
	ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error)
	// Gets a specific artifact.
	GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (*GetArtifactResponse, error)
	// Updates an artifact.
	UpdateArtifact(ctx context.Context, in *UpdateArtifactRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes an artifact.
	DeleteArtifact(ctx context.Context, in *DeleteArtifactRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Watches inventory of artifacts for changes.
	WatchArtifacts(ctx context.Context, in *WatchArtifactsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchArtifactsResponse], error)
}

type catalogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCatalogServiceClient(cc grpc.ClientConnInterface) CatalogServiceClient {
	return &catalogServiceClient{cc}
}

func (c *catalogServiceClient) UploadCatalogEntities(ctx context.Context, in *UploadCatalogEntitiesRequest, opts ...grpc.CallOption) (*UploadCatalogEntitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadCatalogEntitiesResponse)
	err := c.cc.Invoke(ctx, CatalogService_UploadCatalogEntities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) CreateRegistry(ctx context.Context, in *CreateRegistryRequest, opts ...grpc.CallOption) (*CreateRegistryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRegistryResponse)
	err := c.cc.Invoke(ctx, CatalogService_CreateRegistry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) ListRegistries(ctx context.Context, in *ListRegistriesRequest, opts ...grpc.CallOption) (*ListRegistriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRegistriesResponse)
	err := c.cc.Invoke(ctx, CatalogService_ListRegistries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetRegistry(ctx context.Context, in *GetRegistryRequest, opts ...grpc.CallOption) (*GetRegistryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegistryResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetRegistry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) UpdateRegistry(ctx context.Context, in *UpdateRegistryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_UpdateRegistry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) DeleteRegistry(ctx context.Context, in *DeleteRegistryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_DeleteRegistry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) WatchRegistries(ctx context.Context, in *WatchRegistriesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchRegistriesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CatalogService_ServiceDesc.Streams[0], CatalogService_WatchRegistries_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchRegistriesRequest, WatchRegistriesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchRegistriesClient = grpc.ServerStreamingClient[WatchRegistriesResponse]

func (c *catalogServiceClient) CreateDeploymentPackage(ctx context.Context, in *CreateDeploymentPackageRequest, opts ...grpc.CallOption) (*CreateDeploymentPackageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDeploymentPackageResponse)
	err := c.cc.Invoke(ctx, CatalogService_CreateDeploymentPackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) ListDeploymentPackages(ctx context.Context, in *ListDeploymentPackagesRequest, opts ...grpc.CallOption) (*ListDeploymentPackagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDeploymentPackagesResponse)
	err := c.cc.Invoke(ctx, CatalogService_ListDeploymentPackages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetDeploymentPackage(ctx context.Context, in *GetDeploymentPackageRequest, opts ...grpc.CallOption) (*GetDeploymentPackageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeploymentPackageResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetDeploymentPackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetDeploymentPackageVersions(ctx context.Context, in *GetDeploymentPackageVersionsRequest, opts ...grpc.CallOption) (*GetDeploymentPackageVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeploymentPackageVersionsResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetDeploymentPackageVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) UpdateDeploymentPackage(ctx context.Context, in *UpdateDeploymentPackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_UpdateDeploymentPackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) DeleteDeploymentPackage(ctx context.Context, in *DeleteDeploymentPackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_DeleteDeploymentPackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) WatchDeploymentPackages(ctx context.Context, in *WatchDeploymentPackagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchDeploymentPackagesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CatalogService_ServiceDesc.Streams[1], CatalogService_WatchDeploymentPackages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchDeploymentPackagesRequest, WatchDeploymentPackagesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchDeploymentPackagesClient = grpc.ServerStreamingClient[WatchDeploymentPackagesResponse]

func (c *catalogServiceClient) CreateApplication(ctx context.Context, in *CreateApplicationRequest, opts ...grpc.CallOption) (*CreateApplicationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateApplicationResponse)
	err := c.cc.Invoke(ctx, CatalogService_CreateApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) ListApplications(ctx context.Context, in *ListApplicationsRequest, opts ...grpc.CallOption) (*ListApplicationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListApplicationsResponse)
	err := c.cc.Invoke(ctx, CatalogService_ListApplications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetApplication(ctx context.Context, in *GetApplicationRequest, opts ...grpc.CallOption) (*GetApplicationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetApplicationResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetApplicationReferenceCount(ctx context.Context, in *GetApplicationReferenceCountRequest, opts ...grpc.CallOption) (*GetApplicationReferenceCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetApplicationReferenceCountResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetApplicationReferenceCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetApplicationVersions(ctx context.Context, in *GetApplicationVersionsRequest, opts ...grpc.CallOption) (*GetApplicationVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetApplicationVersionsResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetApplicationVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) UpdateApplication(ctx context.Context, in *UpdateApplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_UpdateApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) DeleteApplication(ctx context.Context, in *DeleteApplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_DeleteApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) WatchApplications(ctx context.Context, in *WatchApplicationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchApplicationsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CatalogService_ServiceDesc.Streams[2], CatalogService_WatchApplications_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchApplicationsRequest, WatchApplicationsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchApplicationsClient = grpc.ServerStreamingClient[WatchApplicationsResponse]

func (c *catalogServiceClient) CreateArtifact(ctx context.Context, in *CreateArtifactRequest, opts ...grpc.CallOption) (*CreateArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateArtifactResponse)
	err := c.cc.Invoke(ctx, CatalogService_CreateArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListArtifactsResponse)
	err := c.cc.Invoke(ctx, CatalogService_ListArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (*GetArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArtifactResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) UpdateArtifact(ctx context.Context, in *UpdateArtifactRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_UpdateArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) DeleteArtifact(ctx context.Context, in *DeleteArtifactRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CatalogService_DeleteArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) WatchArtifacts(ctx context.Context, in *WatchArtifactsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchArtifactsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CatalogService_ServiceDesc.Streams[3], CatalogService_WatchArtifacts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchArtifactsRequest, WatchArtifactsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchArtifactsClient = grpc.ServerStreamingClient[WatchArtifactsResponse]

// CatalogServiceServer is the server API for CatalogService service.
// All implementations should embed UnimplementedCatalogServiceServer
// for forward compatibility.
//
// CatalogService provides API to manage the inventory of applications, deployment packages, and other resources related
// to deployment of applications at the network edge.
//
// The principal resources managed by the application catalog service are as follows:
// - [Application](catalog.v3.Application) represents a Helm\* chart that can be deployed to one or more Kubernetes\* pods.
//
//   - [DeploymentPackage](catalog.v3.DeploymentPackage) represents a collection of applications (referenced by their name and a version) that are
//     deployed together. The package can define one or more deployment profiles that specify the individual application
//     profiles to be used when deploying each application. If applications need to be deployed in a particular order, the
//     package can also define any startup dependencies between its constituent applications as a set of dependency graph edges.
//
//   - [Registry](catalog.v3.Registry) represents a repository from which various artifacts, such as application Docker\* images or Helm charts,
//     can be retrieved. As such, registry entity holds information used for finding and accessing the represented repository.
//
//   - [Artifact](catalog.v3.Artifact) represents a binary artifact that can be used for various purposes, e.g. icon or thumbnail for UI display, or
//     auxiliary artifacts for integration with various platform services such as Grafana\* dashboard and similar. An artifact may be
//     used by multiple deployment packages.
//
// The API provides Create, Get, List, Update, Delete, and Watch operations for each of the above resources.
type CatalogServiceServer interface {
	// Allows uploading of a YAML file containing various application catalog entities. Multiple RPC invocations
	// tagged with the same upload session ID can be used to upload multiple files and to create or update several
	// catalog entities as a single transaction.
	UploadCatalogEntities(context.Context, *UploadCatalogEntitiesRequest) (*UploadCatalogEntitiesResponse, error)
	// Creates a new registry.
	CreateRegistry(context.Context, *CreateRegistryRequest) (*CreateRegistryResponse, error)
	// Gets a list of registries.
	ListRegistries(context.Context, *ListRegistriesRequest) (*ListRegistriesResponse, error)
	// Gets a specific registry.
	GetRegistry(context.Context, *GetRegistryRequest) (*GetRegistryResponse, error)
	// Updates a registry.
	UpdateRegistry(context.Context, *UpdateRegistryRequest) (*emptypb.Empty, error)
	// Deletes a registry.
	DeleteRegistry(context.Context, *DeleteRegistryRequest) (*emptypb.Empty, error)
	// Watches inventory of registries for changes.
	WatchRegistries(*WatchRegistriesRequest, grpc.ServerStreamingServer[WatchRegistriesResponse]) error
	// Creates a new deployment package.
	CreateDeploymentPackage(context.Context, *CreateDeploymentPackageRequest) (*CreateDeploymentPackageResponse, error)
	// Gets a list of deployment packages.
	ListDeploymentPackages(context.Context, *ListDeploymentPackagesRequest) (*ListDeploymentPackagesResponse, error)
	// Gets a specific deployment package.
	GetDeploymentPackage(context.Context, *GetDeploymentPackageRequest) (*GetDeploymentPackageResponse, error)
	// Gets all versions of a named deployment package.
	GetDeploymentPackageVersions(context.Context, *GetDeploymentPackageVersionsRequest) (*GetDeploymentPackageVersionsResponse, error)
	// Updates a deployment package.
	UpdateDeploymentPackage(context.Context, *UpdateDeploymentPackageRequest) (*emptypb.Empty, error)
	// Deletes a deployment package.
	DeleteDeploymentPackage(context.Context, *DeleteDeploymentPackageRequest) (*emptypb.Empty, error)
	// Watches inventory of deployment packages for changes.
	WatchDeploymentPackages(*WatchDeploymentPackagesRequest, grpc.ServerStreamingServer[WatchDeploymentPackagesResponse]) error
	// Creates a new application.
	CreateApplication(context.Context, *CreateApplicationRequest) (*CreateApplicationResponse, error)
	// Gets a list of applications.
	ListApplications(context.Context, *ListApplicationsRequest) (*ListApplicationsResponse, error)
	// Gets a specific application.
	GetApplication(context.Context, *GetApplicationRequest) (*GetApplicationResponse, error)
	// Gets application reference count - the number of deployment packages using this application.
	GetApplicationReferenceCount(context.Context, *GetApplicationReferenceCountRequest) (*GetApplicationReferenceCountResponse, error)
	// Gets all versions of a named application.
	GetApplicationVersions(context.Context, *GetApplicationVersionsRequest) (*GetApplicationVersionsResponse, error)
	// Updates an application.
	UpdateApplication(context.Context, *UpdateApplicationRequest) (*emptypb.Empty, error)
	// Deletes an application.
	DeleteApplication(context.Context, *DeleteApplicationRequest) (*emptypb.Empty, error)
	// Watches inventory of applications for changes.
	WatchApplications(*WatchApplicationsRequest, grpc.ServerStreamingServer[WatchApplicationsResponse]) error
	// Creates a new artifact.
	CreateArtifact(context.Context, *CreateArtifactRequest) (*CreateArtifactResponse, error)
	// Gets a list of artifacts.
	ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error)
	// Gets a specific artifact.
	GetArtifact(context.Context, *GetArtifactRequest) (*GetArtifactResponse, error)
	// Updates an artifact.
	UpdateArtifact(context.Context, *UpdateArtifactRequest) (*emptypb.Empty, error)
	// Deletes an artifact.
	DeleteArtifact(context.Context, *DeleteArtifactRequest) (*emptypb.Empty, error)
	// Watches inventory of artifacts for changes.
	WatchArtifacts(*WatchArtifactsRequest, grpc.ServerStreamingServer[WatchArtifactsResponse]) error
}

// UnimplementedCatalogServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCatalogServiceServer struct{}

func (UnimplementedCatalogServiceServer) UploadCatalogEntities(context.Context, *UploadCatalogEntitiesRequest) (*UploadCatalogEntitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadCatalogEntities not implemented")
}
func (UnimplementedCatalogServiceServer) CreateRegistry(context.Context, *CreateRegistryRequest) (*CreateRegistryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRegistry not implemented")
}
func (UnimplementedCatalogServiceServer) ListRegistries(context.Context, *ListRegistriesRequest) (*ListRegistriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRegistries not implemented")
}
func (UnimplementedCatalogServiceServer) GetRegistry(context.Context, *GetRegistryRequest) (*GetRegistryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegistry not implemented")
}
func (UnimplementedCatalogServiceServer) UpdateRegistry(context.Context, *UpdateRegistryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRegistry not implemented")
}
func (UnimplementedCatalogServiceServer) DeleteRegistry(context.Context, *DeleteRegistryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRegistry not implemented")
}
func (UnimplementedCatalogServiceServer) WatchRegistries(*WatchRegistriesRequest, grpc.ServerStreamingServer[WatchRegistriesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchRegistries not implemented")
}
func (UnimplementedCatalogServiceServer) CreateDeploymentPackage(context.Context, *CreateDeploymentPackageRequest) (*CreateDeploymentPackageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeploymentPackage not implemented")
}
func (UnimplementedCatalogServiceServer) ListDeploymentPackages(context.Context, *ListDeploymentPackagesRequest) (*ListDeploymentPackagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeploymentPackages not implemented")
}
func (UnimplementedCatalogServiceServer) GetDeploymentPackage(context.Context, *GetDeploymentPackageRequest) (*GetDeploymentPackageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentPackage not implemented")
}
func (UnimplementedCatalogServiceServer) GetDeploymentPackageVersions(context.Context, *GetDeploymentPackageVersionsRequest) (*GetDeploymentPackageVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentPackageVersions not implemented")
}
func (UnimplementedCatalogServiceServer) UpdateDeploymentPackage(context.Context, *UpdateDeploymentPackageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeploymentPackage not implemented")
}
func (UnimplementedCatalogServiceServer) DeleteDeploymentPackage(context.Context, *DeleteDeploymentPackageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDeploymentPackage not implemented")
}
func (UnimplementedCatalogServiceServer) WatchDeploymentPackages(*WatchDeploymentPackagesRequest, grpc.ServerStreamingServer[WatchDeploymentPackagesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchDeploymentPackages not implemented")
}
func (UnimplementedCatalogServiceServer) CreateApplication(context.Context, *CreateApplicationRequest) (*CreateApplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApplication not implemented")
}
func (UnimplementedCatalogServiceServer) ListApplications(context.Context, *ListApplicationsRequest) (*ListApplicationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListApplications not implemented")
}
func (UnimplementedCatalogServiceServer) GetApplication(context.Context, *GetApplicationRequest) (*GetApplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApplication not implemented")
}
func (UnimplementedCatalogServiceServer) GetApplicationReferenceCount(context.Context, *GetApplicationReferenceCountRequest) (*GetApplicationReferenceCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApplicationReferenceCount not implemented")
}
func (UnimplementedCatalogServiceServer) GetApplicationVersions(context.Context, *GetApplicationVersionsRequest) (*GetApplicationVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApplicationVersions not implemented")
}
func (UnimplementedCatalogServiceServer) UpdateApplication(context.Context, *UpdateApplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApplication not implemented")
}
func (UnimplementedCatalogServiceServer) DeleteApplication(context.Context, *DeleteApplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApplication not implemented")
}
func (UnimplementedCatalogServiceServer) WatchApplications(*WatchApplicationsRequest, grpc.ServerStreamingServer[WatchApplicationsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchApplications not implemented")
}
func (UnimplementedCatalogServiceServer) CreateArtifact(context.Context, *CreateArtifactRequest) (*CreateArtifactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArtifact not implemented")
}
func (UnimplementedCatalogServiceServer) ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArtifacts not implemented")
}
func (UnimplementedCatalogServiceServer) GetArtifact(context.Context, *GetArtifactRequest) (*GetArtifactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtifact not implemented")
}
func (UnimplementedCatalogServiceServer) UpdateArtifact(context.Context, *UpdateArtifactRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArtifact not implemented")
}
func (UnimplementedCatalogServiceServer) DeleteArtifact(context.Context, *DeleteArtifactRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteArtifact not implemented")
}
func (UnimplementedCatalogServiceServer) WatchArtifacts(*WatchArtifactsRequest, grpc.ServerStreamingServer[WatchArtifactsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchArtifacts not implemented")
}
func (UnimplementedCatalogServiceServer) testEmbeddedByValue() {}

// UnsafeCatalogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CatalogServiceServer will
// result in compilation errors.
type UnsafeCatalogServiceServer interface {
	mustEmbedUnimplementedCatalogServiceServer()
}

func RegisterCatalogServiceServer(s grpc.ServiceRegistrar, srv CatalogServiceServer) {
	// If the following call pancis, it indicates UnimplementedCatalogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CatalogService_ServiceDesc, srv)
}

func _CatalogService_UploadCatalogEntities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadCatalogEntitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UploadCatalogEntities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UploadCatalogEntities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UploadCatalogEntities(ctx, req.(*UploadCatalogEntitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_CreateRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRegistryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).CreateRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_CreateRegistry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).CreateRegistry(ctx, req.(*CreateRegistryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_ListRegistries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegistriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).ListRegistries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_ListRegistries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).ListRegistries(ctx, req.(*ListRegistriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegistryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetRegistry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetRegistry(ctx, req.(*GetRegistryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_UpdateRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegistryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UpdateRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UpdateRegistry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UpdateRegistry(ctx, req.(*UpdateRegistryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_DeleteRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegistryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).DeleteRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_DeleteRegistry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).DeleteRegistry(ctx, req.(*DeleteRegistryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_WatchRegistries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRegistriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CatalogServiceServer).WatchRegistries(m, &grpc.GenericServerStream[WatchRegistriesRequest, WatchRegistriesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchRegistriesServer = grpc.ServerStreamingServer[WatchRegistriesResponse]

func _CatalogService_CreateDeploymentPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeploymentPackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).CreateDeploymentPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_CreateDeploymentPackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).CreateDeploymentPackage(ctx, req.(*CreateDeploymentPackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_ListDeploymentPackages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDeploymentPackagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).ListDeploymentPackages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_ListDeploymentPackages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).ListDeploymentPackages(ctx, req.(*ListDeploymentPackagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetDeploymentPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeploymentPackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetDeploymentPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetDeploymentPackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetDeploymentPackage(ctx, req.(*GetDeploymentPackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetDeploymentPackageVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeploymentPackageVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetDeploymentPackageVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetDeploymentPackageVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetDeploymentPackageVersions(ctx, req.(*GetDeploymentPackageVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_UpdateDeploymentPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDeploymentPackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UpdateDeploymentPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UpdateDeploymentPackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UpdateDeploymentPackage(ctx, req.(*UpdateDeploymentPackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_DeleteDeploymentPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDeploymentPackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).DeleteDeploymentPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_DeleteDeploymentPackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).DeleteDeploymentPackage(ctx, req.(*DeleteDeploymentPackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_WatchDeploymentPackages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchDeploymentPackagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CatalogServiceServer).WatchDeploymentPackages(m, &grpc.GenericServerStream[WatchDeploymentPackagesRequest, WatchDeploymentPackagesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchDeploymentPackagesServer = grpc.ServerStreamingServer[WatchDeploymentPackagesResponse]

func _CatalogService_CreateApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateApplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).CreateApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_CreateApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).CreateApplication(ctx, req.(*CreateApplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_ListApplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListApplicationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).ListApplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_ListApplications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).ListApplications(ctx, req.(*ListApplicationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetApplication(ctx, req.(*GetApplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetApplicationReferenceCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplicationReferenceCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetApplicationReferenceCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetApplicationReferenceCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetApplicationReferenceCount(ctx, req.(*GetApplicationReferenceCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetApplicationVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplicationVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetApplicationVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetApplicationVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetApplicationVersions(ctx, req.(*GetApplicationVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_UpdateApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateApplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UpdateApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UpdateApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UpdateApplication(ctx, req.(*UpdateApplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_DeleteApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteApplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).DeleteApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_DeleteApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).DeleteApplication(ctx, req.(*DeleteApplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_WatchApplications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchApplicationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CatalogServiceServer).WatchApplications(m, &grpc.GenericServerStream[WatchApplicationsRequest, WatchApplicationsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchApplicationsServer = grpc.ServerStreamingServer[WatchApplicationsResponse]

func _CatalogService_CreateArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).CreateArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_CreateArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).CreateArtifact(ctx, req.(*CreateArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_ListArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).ListArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_ListArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).ListArtifacts(ctx, req.(*ListArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetArtifact(ctx, req.(*GetArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_UpdateArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UpdateArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UpdateArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UpdateArtifact(ctx, req.(*UpdateArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_DeleteArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).DeleteArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_DeleteArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).DeleteArtifact(ctx, req.(*DeleteArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_WatchArtifacts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchArtifactsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CatalogServiceServer).WatchArtifacts(m, &grpc.GenericServerStream[WatchArtifactsRequest, WatchArtifactsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CatalogService_WatchArtifactsServer = grpc.ServerStreamingServer[WatchArtifactsResponse]

// CatalogService_ServiceDesc is the grpc.ServiceDesc for CatalogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CatalogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "catalog.v3.CatalogService",
	HandlerType: (*CatalogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadCatalogEntities",
			Handler:    _CatalogService_UploadCatalogEntities_Handler,
		},
		{
			MethodName: "CreateRegistry",
			Handler:    _CatalogService_CreateRegistry_Handler,
		},
		{
			MethodName: "ListRegistries",
			Handler:    _CatalogService_ListRegistries_Handler,
		},
		{
			MethodName: "GetRegistry",
			Handler:    _CatalogService_GetRegistry_Handler,
		},
		{
			MethodName: "UpdateRegistry",
			Handler:    _CatalogService_UpdateRegistry_Handler,
		},
		{
			MethodName: "DeleteRegistry",
			Handler:    _CatalogService_DeleteRegistry_Handler,
		},
		{
			MethodName: "CreateDeploymentPackage",
			Handler:    _CatalogService_CreateDeploymentPackage_Handler,
		},
		{
			MethodName: "ListDeploymentPackages",
			Handler:    _CatalogService_ListDeploymentPackages_Handler,
		},
		{
			MethodName: "GetDeploymentPackage",
			Handler:    _CatalogService_GetDeploymentPackage_Handler,
		},
		{
			MethodName: "GetDeploymentPackageVersions",
			Handler:    _CatalogService_GetDeploymentPackageVersions_Handler,
		},
		{
			MethodName: "UpdateDeploymentPackage",
			Handler:    _CatalogService_UpdateDeploymentPackage_Handler,
		},
		{
			MethodName: "DeleteDeploymentPackage",
			Handler:    _CatalogService_DeleteDeploymentPackage_Handler,
		},
		{
			MethodName: "CreateApplication",
			Handler:    _CatalogService_CreateApplication_Handler,
		},
		{
			MethodName: "ListApplications",
			Handler:    _CatalogService_ListApplications_Handler,
		},
		{
			MethodName: "GetApplication",
			Handler:    _CatalogService_GetApplication_Handler,
		},
		{
			MethodName: "GetApplicationReferenceCount",
			Handler:    _CatalogService_GetApplicationReferenceCount_Handler,
		},
		{
			MethodName: "GetApplicationVersions",
			Handler:    _CatalogService_GetApplicationVersions_Handler,
		},
		{
			MethodName: "UpdateApplication",
			Handler:    _CatalogService_UpdateApplication_Handler,
		},
		{
			MethodName: "DeleteApplication",
			Handler:    _CatalogService_DeleteApplication_Handler,
		},
		{
			MethodName: "CreateArtifact",
			Handler:    _CatalogService_CreateArtifact_Handler,
		},
		{
			MethodName: "ListArtifacts",
			Handler:    _CatalogService_ListArtifacts_Handler,
		},
		{
			MethodName: "GetArtifact",
			Handler:    _CatalogService_GetArtifact_Handler,
		},
		{
			MethodName: "UpdateArtifact",
			Handler:    _CatalogService_UpdateArtifact_Handler,
		},
		{
			MethodName: "DeleteArtifact",
			Handler:    _CatalogService_DeleteArtifact_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchRegistries",
			Handler:       _CatalogService_WatchRegistries_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchDeploymentPackages",
			Handler:       _CatalogService_WatchDeploymentPackages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchApplications",
			Handler:       _CatalogService_WatchApplications_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchArtifacts",
			Handler:       _CatalogService_WatchArtifacts_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "catalog/v3/service.proto",
}
