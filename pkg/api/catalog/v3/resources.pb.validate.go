// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: catalog/v3/resources.proto

package catalogv3

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Event) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EventMultiError, or nil if none found.
func (m *Event) ValidateAll() error {
	return m.validate(true)
}

func (m *Event) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetType()) != 7 {
		err := EventValidationError{
			field:  "Type",
			reason: "value length must be 7 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if !_Event_Type_Pattern.MatchString(m.GetType()) {
		err := EventValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^(replayed)$|^(created)$|^(updated)$|^(deleted)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProjectId

	if len(errors) > 0 {
		return EventMultiError(errors)
	}

	return nil
}

// EventMultiError is an error wrapping multiple validation errors returned by
// Event.ValidateAll() if the designated constraints aren't met.
type EventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventMultiError) AllErrors() []error { return m }

// EventValidationError is the validation error returned by Event.Validate if
// the designated constraints aren't met.
type EventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventValidationError) ErrorName() string { return "EventValidationError" }

// Error satisfies the builtin error interface
func (e EventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventValidationError{}

var _Event_Type_Pattern = regexp.MustCompile("^(replayed)$|^(created)$|^(updated)$|^(deleted)$")

// Validate checks the field values on Registry with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Registry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Registry with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegistryMultiError, or nil
// if none found.
func (m *Registry) ValidateAll() error {
	return m.validate(true)
}

func (m *Registry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := RegistryValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Registry_Name_Pattern.MatchString(m.GetName()) {
		err := RegistryValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 40 {
		err := RegistryValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Registry_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := RegistryValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
		err := RegistryValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRootUrl()); l < 1 || l > 1000 {
		err := RegistryValidationError{
			field:  "RootUrl",
			reason: "value length must be between 1 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Registry_RootUrl_Pattern.MatchString(m.GetRootUrl()) {
		err := RegistryValidationError{
			field:  "RootUrl",
			reason: "value does not match regex pattern \"^(https?|oci)://[a-z0-9-]+(.[a-z0-9-]+)+([/?][\\\\w_\\\\-@:%.+~#?&/=]*)?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUsername()); l < 0 || l > 1000 {
		err := RegistryValidationError{
			field:  "Username",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Registry_Username_Pattern.MatchString(m.GetUsername()) {
		err := RegistryValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAuthToken()); l < 0 || l > 4500 {
		err := RegistryValidationError{
			field:  "AuthToken",
			reason: "value length must be between 0 and 4500 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Registry_AuthToken_Pattern.MatchString(m.GetAuthToken()) {
		err := RegistryValidationError{
			field:  "AuthToken",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetType()); l < 1 || l > 40 {
		err := RegistryValidationError{
			field:  "Type",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Registry_Type_Pattern.MatchString(m.GetType()) {
		err := RegistryValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^(HELM)$|^(IMAGE)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCacerts()); l < 0 || l > 16384 {
		err := RegistryValidationError{
			field:  "Cacerts",
			reason: "value length must be between 0 and 16384 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApiType()); l < 0 || l > 16 {
		err := RegistryValidationError{
			field:  "ApiType",
			reason: "value length must be between 0 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Registry_ApiType_Pattern.MatchString(m.GetApiType()) {
		err := RegistryValidationError{
			field:  "ApiType",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetInventoryUrl()); l < 0 || l > 1000 {
		err := RegistryValidationError{
			field:  "InventoryUrl",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegistryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegistryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegistryValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegistryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegistryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegistryValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegistryMultiError(errors)
	}

	return nil
}

// RegistryMultiError is an error wrapping multiple validation errors returned
// by Registry.ValidateAll() if the designated constraints aren't met.
type RegistryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegistryMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegistryMultiError) AllErrors() []error { return m }

// RegistryValidationError is the validation error returned by
// Registry.Validate if the designated constraints aren't met.
type RegistryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegistryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegistryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegistryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegistryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegistryValidationError) ErrorName() string { return "RegistryValidationError" }

// Error satisfies the builtin error interface
func (e RegistryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegistry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegistryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegistryValidationError{}

var _Registry_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _Registry_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

var _Registry_RootUrl_Pattern = regexp.MustCompile("^(https?|oci)://[a-z0-9-]+(.[a-z0-9-]+)+([/?][\\w_\\-@:%.+~#?&/=]*)?$")

var _Registry_Username_Pattern = regexp.MustCompile("^\\PC*$")

var _Registry_AuthToken_Pattern = regexp.MustCompile("^\\PC*$")

var _Registry_Type_Pattern = regexp.MustCompile("^(HELM)$|^(IMAGE)$")

var _Registry_ApiType_Pattern = regexp.MustCompile("^\\PC*$")

// Validate checks the field values on DeploymentPackage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeploymentPackage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentPackage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentPackageMultiError, or nil if none found.
func (m *DeploymentPackage) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentPackage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := DeploymentPackageValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentPackage_Name_Pattern.MatchString(m.GetName()) {
		err := DeploymentPackageValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 40 {
		err := DeploymentPackageValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentPackage_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := DeploymentPackageValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
		err := DeploymentPackageValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 20 {
		err := DeploymentPackageValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentPackage_Version_Pattern.MatchString(m.GetVersion()) {
		err := DeploymentPackageValidationError{
			field:  "Version",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Kind

	for idx, item := range m.GetApplicationReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("ApplicationReferences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("ApplicationReferences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentPackageValidationError{
					field:  fmt.Sprintf("ApplicationReferences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsDeployed

	// no validation rules for IsVisible

	for idx, item := range m.GetProfiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Profiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Profiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentPackageValidationError{
					field:  fmt.Sprintf("Profiles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DefaultProfileName

	for idx, item := range m.GetApplicationDependencies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("ApplicationDependencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("ApplicationDependencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentPackageValidationError{
					field:  fmt.Sprintf("ApplicationDependencies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetExtensions()) > 100 {
		err := DeploymentPackageValidationError{
			field:  "Extensions",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Extensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Extensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentPackageValidationError{
					field:  fmt.Sprintf("Extensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetArtifacts()) > 100 {
		err := DeploymentPackageValidationError{
			field:  "Artifacts",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetArtifacts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Artifacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Artifacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentPackageValidationError{
					field:  fmt.Sprintf("Artifacts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DefaultNamespaces

	// no validation rules for ForbidsMultipleDeployments

	for idx, item := range m.GetNamespaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Namespaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentPackageValidationError{
						field:  fmt.Sprintf("Namespaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentPackageValidationError{
					field:  fmt.Sprintf("Namespaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentPackageValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentPackageValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentPackageValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentPackageValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentPackageValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentPackageValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeploymentPackageMultiError(errors)
	}

	return nil
}

// DeploymentPackageMultiError is an error wrapping multiple validation errors
// returned by DeploymentPackage.ValidateAll() if the designated constraints
// aren't met.
type DeploymentPackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentPackageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentPackageMultiError) AllErrors() []error { return m }

// DeploymentPackageValidationError is the validation error returned by
// DeploymentPackage.Validate if the designated constraints aren't met.
type DeploymentPackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentPackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentPackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentPackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentPackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentPackageValidationError) ErrorName() string {
	return "DeploymentPackageValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentPackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentPackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentPackageValidationError{}

var _DeploymentPackage_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _DeploymentPackage_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

var _DeploymentPackage_Version_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$")

// Validate checks the field values on DeploymentProfile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeploymentProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentProfileMultiError, or nil if none found.
func (m *DeploymentProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := DeploymentProfileValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentProfile_Name_Pattern.MatchString(m.GetName()) {
		err := DeploymentProfileValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 40 {
		err := DeploymentProfileValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentProfile_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := DeploymentProfileValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
		err := DeploymentProfileValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ApplicationProfiles

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentProfileValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentProfileValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentProfileValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentProfileValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentProfileValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentProfileValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeploymentProfileMultiError(errors)
	}

	return nil
}

// DeploymentProfileMultiError is an error wrapping multiple validation errors
// returned by DeploymentProfile.ValidateAll() if the designated constraints
// aren't met.
type DeploymentProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentProfileMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentProfileMultiError) AllErrors() []error { return m }

// DeploymentProfileValidationError is the validation error returned by
// DeploymentProfile.Validate if the designated constraints aren't met.
type DeploymentProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentProfileValidationError) ErrorName() string {
	return "DeploymentProfileValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentProfileValidationError{}

var _DeploymentProfile_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _DeploymentProfile_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

// Validate checks the field values on ApplicationReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationReferenceMultiError, or nil if none found.
func (m *ApplicationReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := ApplicationReferenceValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationReference_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationReferenceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 20 {
		err := ApplicationReferenceValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationReference_Version_Pattern.MatchString(m.GetVersion()) {
		err := ApplicationReferenceValidationError{
			field:  "Version",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationReferenceMultiError(errors)
	}

	return nil
}

// ApplicationReferenceMultiError is an error wrapping multiple validation
// errors returned by ApplicationReference.ValidateAll() if the designated
// constraints aren't met.
type ApplicationReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationReferenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationReferenceMultiError) AllErrors() []error { return m }

// ApplicationReferenceValidationError is the validation error returned by
// ApplicationReference.Validate if the designated constraints aren't met.
type ApplicationReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationReferenceValidationError) ErrorName() string {
	return "ApplicationReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationReferenceValidationError{}

var _ApplicationReference_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _ApplicationReference_Version_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$")

// Validate checks the field values on ApplicationDependency with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationDependency) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationDependency with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationDependencyMultiError, or nil if none found.
func (m *ApplicationDependency) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationDependency) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 26 {
		err := ApplicationDependencyValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 26 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationDependency_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationDependencyValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,24}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRequires()); l < 1 || l > 26 {
		err := ApplicationDependencyValidationError{
			field:  "Requires",
			reason: "value length must be between 1 and 26 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationDependency_Requires_Pattern.MatchString(m.GetRequires()) {
		err := ApplicationDependencyValidationError{
			field:  "Requires",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,24}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationDependencyMultiError(errors)
	}

	return nil
}

// ApplicationDependencyMultiError is an error wrapping multiple validation
// errors returned by ApplicationDependency.ValidateAll() if the designated
// constraints aren't met.
type ApplicationDependencyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationDependencyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationDependencyMultiError) AllErrors() []error { return m }

// ApplicationDependencyValidationError is the validation error returned by
// ApplicationDependency.Validate if the designated constraints aren't met.
type ApplicationDependencyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationDependencyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationDependencyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationDependencyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationDependencyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationDependencyValidationError) ErrorName() string {
	return "ApplicationDependencyValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationDependencyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationDependency.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationDependencyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationDependencyValidationError{}

var _ApplicationDependency_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,24}[a-z0-9]{0,1}$")

var _ApplicationDependency_Requires_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,24}[a-z0-9]{0,1}$")

// Validate checks the field values on APIExtension with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *APIExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APIExtension with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in APIExtensionMultiError, or
// nil if none found.
func (m *APIExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *APIExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := APIExtensionValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_APIExtension_Name_Pattern.MatchString(m.GetName()) {
		err := APIExtensionValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 20 {
		err := APIExtensionValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_APIExtension_Version_Pattern.MatchString(m.GetVersion()) {
		err := APIExtensionValidationError{
			field:  "Version",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 40 {
		err := APIExtensionValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_APIExtension_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := APIExtensionValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
		err := APIExtensionValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetEndpoints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, APIExtensionValidationError{
						field:  fmt.Sprintf("Endpoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, APIExtensionValidationError{
						field:  fmt.Sprintf("Endpoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return APIExtensionValidationError{
					field:  fmt.Sprintf("Endpoints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetUiExtension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, APIExtensionValidationError{
					field:  "UiExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, APIExtensionValidationError{
					field:  "UiExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUiExtension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return APIExtensionValidationError{
				field:  "UiExtension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return APIExtensionMultiError(errors)
	}

	return nil
}

// APIExtensionMultiError is an error wrapping multiple validation errors
// returned by APIExtension.ValidateAll() if the designated constraints aren't met.
type APIExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIExtensionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIExtensionMultiError) AllErrors() []error { return m }

// APIExtensionValidationError is the validation error returned by
// APIExtension.Validate if the designated constraints aren't met.
type APIExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIExtensionValidationError) ErrorName() string { return "APIExtensionValidationError" }

// Error satisfies the builtin error interface
func (e APIExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPIExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIExtensionValidationError{}

var _APIExtension_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _APIExtension_Version_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$")

var _APIExtension_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

// Validate checks the field values on UIExtension with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UIExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UIExtension with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UIExtensionMultiError, or
// nil if none found.
func (m *UIExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *UIExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLabel()); l < 0 || l > 40 {
		err := UIExtensionValidationError{
			field:  "Label",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UIExtension_Label_Pattern.MatchString(m.GetLabel()) {
		err := UIExtensionValidationError{
			field:  "Label",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetServiceName()); l < 1 || l > 40 {
		err := UIExtensionValidationError{
			field:  "ServiceName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 1000 {
		err := UIExtensionValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFileName()); l < 1 || l > 40 {
		err := UIExtensionValidationError{
			field:  "FileName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppName()); l < 1 || l > 40 {
		err := UIExtensionValidationError{
			field:  "AppName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetModuleName()); l < 1 || l > 40 {
		err := UIExtensionValidationError{
			field:  "ModuleName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UIExtensionMultiError(errors)
	}

	return nil
}

// UIExtensionMultiError is an error wrapping multiple validation errors
// returned by UIExtension.ValidateAll() if the designated constraints aren't met.
type UIExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UIExtensionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UIExtensionMultiError) AllErrors() []error { return m }

// UIExtensionValidationError is the validation error returned by
// UIExtension.Validate if the designated constraints aren't met.
type UIExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UIExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UIExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UIExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UIExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UIExtensionValidationError) ErrorName() string { return "UIExtensionValidationError" }

// Error satisfies the builtin error interface
func (e UIExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUIExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UIExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UIExtensionValidationError{}

var _UIExtension_Label_Pattern = regexp.MustCompile("^\\PC*$")

// Validate checks the field values on Endpoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Endpoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Endpoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EndpointMultiError, or nil
// if none found.
func (m *Endpoint) ValidateAll() error {
	return m.validate(true)
}

func (m *Endpoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServiceName()); l < 1 || l > 40 {
		err := EndpointValidationError{
			field:  "ServiceName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Endpoint_ServiceName_Pattern.MatchString(m.GetServiceName()) {
		err := EndpointValidationError{
			field:  "ServiceName",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetExternalPath()); l < 1 || l > 128 {
		err := EndpointValidationError{
			field:  "ExternalPath",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetInternalPath()); l < 1 || l > 128 {
		err := EndpointValidationError{
			field:  "InternalPath",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetScheme()); l < 0 || l > 32 {
		err := EndpointValidationError{
			field:  "Scheme",
			reason: "value length must be between 0 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Endpoint_Scheme_Pattern.MatchString(m.GetScheme()) {
		err := EndpointValidationError{
			field:  "Scheme",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9-]{0,30}[a-z0-9]){0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAuthType()); l < 0 || l > 16 {
		err := EndpointValidationError{
			field:  "AuthType",
			reason: "value length must be between 0 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Endpoint_AuthType_Pattern.MatchString(m.GetAuthType()) {
		err := EndpointValidationError{
			field:  "AuthType",
			reason: "value does not match regex pattern \"^[a-z]{0,16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppName()); l < 0 || l > 40 {
		err := EndpointValidationError{
			field:  "AppName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EndpointMultiError(errors)
	}

	return nil
}

// EndpointMultiError is an error wrapping multiple validation errors returned
// by Endpoint.ValidateAll() if the designated constraints aren't met.
type EndpointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EndpointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EndpointMultiError) AllErrors() []error { return m }

// EndpointValidationError is the validation error returned by
// Endpoint.Validate if the designated constraints aren't met.
type EndpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndpointValidationError) ErrorName() string { return "EndpointValidationError" }

// Error satisfies the builtin error interface
func (e EndpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndpointValidationError{}

var _Endpoint_ServiceName_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _Endpoint_Scheme_Pattern = regexp.MustCompile("^([a-z][a-z0-9-]{0,30}[a-z0-9]){0,1}$")

var _Endpoint_AuthType_Pattern = regexp.MustCompile("^[a-z]{0,16}$")

// Validate checks the field values on ArtifactReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ArtifactReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArtifactReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArtifactReferenceMultiError, or nil if none found.
func (m *ArtifactReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ArtifactReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := ArtifactReferenceValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ArtifactReference_Name_Pattern.MatchString(m.GetName()) {
		err := ArtifactReferenceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPurpose()); l < 0 || l > 20 {
		err := ArtifactReferenceValidationError{
			field:  "Purpose",
			reason: "value length must be between 0 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ArtifactReference_Purpose_Pattern.MatchString(m.GetPurpose()) {
		err := ArtifactReferenceValidationError{
			field:  "Purpose",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ArtifactReferenceMultiError(errors)
	}

	return nil
}

// ArtifactReferenceMultiError is an error wrapping multiple validation errors
// returned by ArtifactReference.ValidateAll() if the designated constraints
// aren't met.
type ArtifactReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArtifactReferenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArtifactReferenceMultiError) AllErrors() []error { return m }

// ArtifactReferenceValidationError is the validation error returned by
// ArtifactReference.Validate if the designated constraints aren't met.
type ArtifactReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArtifactReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArtifactReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArtifactReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArtifactReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArtifactReferenceValidationError) ErrorName() string {
	return "ArtifactReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ArtifactReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArtifactReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArtifactReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArtifactReferenceValidationError{}

var _ArtifactReference_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _ArtifactReference_Purpose_Pattern = regexp.MustCompile("^\\PC*$")

// Validate checks the field values on Namespace with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Namespace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Namespace with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamespaceMultiError, or nil
// if none found.
func (m *Namespace) ValidateAll() error {
	return m.validate(true)
}

func (m *Namespace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := NamespaceValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Namespace_Name_Pattern.MatchString(m.GetName()) {
		err := NamespaceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return NamespaceMultiError(errors)
	}

	return nil
}

// NamespaceMultiError is an error wrapping multiple validation errors returned
// by Namespace.ValidateAll() if the designated constraints aren't met.
type NamespaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceMultiError) AllErrors() []error { return m }

// NamespaceValidationError is the validation error returned by
// Namespace.Validate if the designated constraints aren't met.
type NamespaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceValidationError) ErrorName() string { return "NamespaceValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceValidationError{}

var _Namespace_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

// Validate checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplicationMultiError, or
// nil if none found.
func (m *Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 26 {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 26 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,24}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 40 {
		err := ApplicationValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := ApplicationValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
		err := ApplicationValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 20 {
		err := ApplicationValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Version_Pattern.MatchString(m.GetVersion()) {
		err := ApplicationValidationError{
			field:  "Version",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Kind

	if l := utf8.RuneCountInString(m.GetChartName()); l < 1 || l > 200 {
		err := ApplicationValidationError{
			field:  "ChartName",
			reason: "value length must be between 1 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_ChartName_Pattern.MatchString(m.GetChartName()) {
		err := ApplicationValidationError{
			field:  "ChartName",
			reason: "value does not match regex pattern \"^[0-9a-z-/]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChartVersion()); l < 1 || l > 53 {
		err := ApplicationValidationError{
			field:  "ChartVersion",
			reason: "value length must be between 1 and 53 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_ChartVersion_Pattern.MatchString(m.GetChartVersion()) {
		err := ApplicationValidationError{
			field:  "ChartVersion",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-.]{0,51}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for HelmRegistryName

	for idx, item := range m.GetProfiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Profiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Profiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Profiles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DefaultProfileName

	// no validation rules for ImageRegistryName

	for idx, item := range m.GetIgnoredResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("IgnoredResources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("IgnoredResources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("IgnoredResources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationMultiError(errors)
	}

	return nil
}

// ApplicationMultiError is an error wrapping multiple validation errors
// returned by Application.ValidateAll() if the designated constraints aren't met.
type ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationMultiError) AllErrors() []error { return m }

// ApplicationValidationError is the validation error returned by
// Application.Validate if the designated constraints aren't met.
type ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationValidationError) ErrorName() string { return "ApplicationValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationValidationError{}

var _Application_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,24}[a-z0-9]{0,1}$")

var _Application_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

var _Application_Version_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$")

var _Application_ChartName_Pattern = regexp.MustCompile("^[0-9a-z-/]*$")

var _Application_ChartVersion_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-.]{0,51}[a-z0-9]{0,1}$")

// Validate checks the field values on ResourceReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResourceReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceReferenceMultiError, or nil if none found.
func (m *ResourceReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := ResourceReferenceValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResourceReference_Name_Pattern.MatchString(m.GetName()) {
		err := ResourceReferenceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-._-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKind()); l < 1 || l > 40 {
		err := ResourceReferenceValidationError{
			field:  "Kind",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResourceReference_Kind_Pattern.MatchString(m.GetKind()) {
		err := ResourceReferenceValidationError{
			field:  "Kind",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9][a-zA-Z0-9._-]{0,38}[a-zA-Z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	if len(errors) > 0 {
		return ResourceReferenceMultiError(errors)
	}

	return nil
}

// ResourceReferenceMultiError is an error wrapping multiple validation errors
// returned by ResourceReference.ValidateAll() if the designated constraints
// aren't met.
type ResourceReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceReferenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceReferenceMultiError) AllErrors() []error { return m }

// ResourceReferenceValidationError is the validation error returned by
// ResourceReference.Validate if the designated constraints aren't met.
type ResourceReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceReferenceValidationError) ErrorName() string {
	return "ResourceReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceReferenceValidationError{}

var _ResourceReference_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-._-]{0,38}[a-z0-9]{0,1}$")

var _ResourceReference_Kind_Pattern = regexp.MustCompile("^[a-zA-Z0-9][a-zA-Z0-9._-]{0,38}[a-zA-Z0-9]{0,1}$")

// Validate checks the field values on ParameterTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ParameterTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterTemplate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterTemplateMultiError, or nil if none found.
func (m *ParameterTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 4096 {
		err := ParameterTemplateValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 4096 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ParameterTemplate_Name_Pattern.MatchString(m.GetName()) {
		err := ParameterTemplateValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-/_\\\\[\\\\]\\\\.\\\\\\\\]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 100 {
		err := ParameterTemplateValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ParameterTemplate_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := ParameterTemplateValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDefault()); l < 0 || l > 4096 {
		err := ParameterTemplateValidationError{
			field:  "Default",
			reason: "value length must be between 0 and 4096 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := ParameterTemplateValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ParameterTemplate_Type_Pattern.MatchString(m.GetType()) {
		err := ParameterTemplateValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^(string)$|^(number)$|^(boolean)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetValidator()); l < 0 || l > 40 {
		err := ParameterTemplateValidationError{
			field:  "Validator",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSuggestedValues()) > 100 {
		err := ParameterTemplateValidationError{
			field:  "SuggestedValues",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ParameterTemplate_SuggestedValues_Unique := make(map[string]struct{}, len(m.GetSuggestedValues()))

	for idx, item := range m.GetSuggestedValues() {
		_, _ = idx, item

		if _, exists := _ParameterTemplate_SuggestedValues_Unique[item]; exists {
			err := ParameterTemplateValidationError{
				field:  fmt.Sprintf("SuggestedValues[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ParameterTemplate_SuggestedValues_Unique[item] = struct{}{}
		}

		if l := utf8.RuneCountInString(item); l < 1 || l > 4096 {
			err := ParameterTemplateValidationError{
				field:  fmt.Sprintf("SuggestedValues[%v]", idx),
				reason: "value length must be between 1 and 4096 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Secret

	// no validation rules for Mandatory

	if len(errors) > 0 {
		return ParameterTemplateMultiError(errors)
	}

	return nil
}

// ParameterTemplateMultiError is an error wrapping multiple validation errors
// returned by ParameterTemplate.ValidateAll() if the designated constraints
// aren't met.
type ParameterTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterTemplateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterTemplateMultiError) AllErrors() []error { return m }

// ParameterTemplateValidationError is the validation error returned by
// ParameterTemplate.Validate if the designated constraints aren't met.
type ParameterTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterTemplateValidationError) ErrorName() string {
	return "ParameterTemplateValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterTemplateValidationError{}

var _ParameterTemplate_Name_Pattern = regexp.MustCompile("^[A-Za-z0-9-/_\\[\\]\\.\\\\]*$")

var _ParameterTemplate_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

var _ParameterTemplate_Type_Pattern = regexp.MustCompile("^(string)$|^(number)$|^(boolean)$")

// Validate checks the field values on Profile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Profile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Profile with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProfileMultiError, or nil if none found.
func (m *Profile) ValidateAll() error {
	return m.validate(true)
}

func (m *Profile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := ProfileValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Profile_Name_Pattern.MatchString(m.GetName()) {
		err := ProfileValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 40 {
		err := ProfileValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Profile_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := ProfileValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
		err := ProfileValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChartValues()); l < 0 || l > 4000000 {
		err := ProfileValidationError{
			field:  "ChartValues",
			reason: "value length must be between 0 and 4000000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameterTemplates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProfileValidationError{
						field:  fmt.Sprintf("ParameterTemplates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProfileValidationError{
						field:  fmt.Sprintf("ParameterTemplates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProfileValidationError{
					field:  fmt.Sprintf("ParameterTemplates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeploymentRequirement() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProfileValidationError{
						field:  fmt.Sprintf("DeploymentRequirement[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProfileValidationError{
						field:  fmt.Sprintf("DeploymentRequirement[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProfileValidationError{
					field:  fmt.Sprintf("DeploymentRequirement[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProfileMultiError(errors)
	}

	return nil
}

// ProfileMultiError is an error wrapping multiple validation errors returned
// by Profile.ValidateAll() if the designated constraints aren't met.
type ProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfileMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfileMultiError) AllErrors() []error { return m }

// ProfileValidationError is the validation error returned by Profile.Validate
// if the designated constraints aren't met.
type ProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfileValidationError) ErrorName() string { return "ProfileValidationError" }

// Error satisfies the builtin error interface
func (e ProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfileValidationError{}

var _Profile_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _Profile_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

// Validate checks the field values on DeploymentRequirement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeploymentRequirement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentRequirement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentRequirementMultiError, or nil if none found.
func (m *DeploymentRequirement) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentRequirement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := DeploymentRequirementValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentRequirement_Name_Pattern.MatchString(m.GetName()) {
		err := DeploymentRequirementValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 20 {
		err := DeploymentRequirementValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentRequirement_Version_Pattern.MatchString(m.GetVersion()) {
		err := DeploymentRequirementValidationError{
			field:  "Version",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DeploymentProfileName

	if len(errors) > 0 {
		return DeploymentRequirementMultiError(errors)
	}

	return nil
}

// DeploymentRequirementMultiError is an error wrapping multiple validation
// errors returned by DeploymentRequirement.ValidateAll() if the designated
// constraints aren't met.
type DeploymentRequirementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentRequirementMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentRequirementMultiError) AllErrors() []error { return m }

// DeploymentRequirementValidationError is the validation error returned by
// DeploymentRequirement.Validate if the designated constraints aren't met.
type DeploymentRequirementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentRequirementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentRequirementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentRequirementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentRequirementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentRequirementValidationError) ErrorName() string {
	return "DeploymentRequirementValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentRequirementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentRequirement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentRequirementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentRequirementValidationError{}

var _DeploymentRequirement_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _DeploymentRequirement_Version_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$")

// Validate checks the field values on Artifact with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Artifact) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Artifact with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArtifactMultiError, or nil
// if none found.
func (m *Artifact) ValidateAll() error {
	return m.validate(true)
}

func (m *Artifact) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := ArtifactValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Artifact_Name_Pattern.MatchString(m.GetName()) {
		err := ArtifactValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 0 || l > 40 {
		err := ArtifactValidationError{
			field:  "DisplayName",
			reason: "value length must be between 0 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Artifact_DisplayName_Pattern.MatchString(m.GetDisplayName()) {
		err := ArtifactValidationError{
			field:  "DisplayName",
			reason: "value does not match regex pattern \"^\\\\PC*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
		err := ArtifactValidationError{
			field:  "Description",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetMimeType()); l < 1 || l > 40 {
		err := ArtifactValidationError{
			field:  "MimeType",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Artifact_MimeType_Pattern.MatchString(m.GetMimeType()) {
		err := ArtifactValidationError{
			field:  "MimeType",
			reason: "value does not match regex pattern \"^(text/plain)$|^(application/json)$|^(application/yaml)$|^(image/png)$|^(image/jpeg)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetArtifact()); l < 4 || l > 4000000 {
		err := ArtifactValidationError{
			field:  "Artifact",
			reason: "value length must be between 4 and 4000000 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArtifactValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArtifactValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArtifactValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArtifactValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArtifactValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArtifactValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ArtifactMultiError(errors)
	}

	return nil
}

// ArtifactMultiError is an error wrapping multiple validation errors returned
// by Artifact.ValidateAll() if the designated constraints aren't met.
type ArtifactMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArtifactMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArtifactMultiError) AllErrors() []error { return m }

// ArtifactValidationError is the validation error returned by
// Artifact.Validate if the designated constraints aren't met.
type ArtifactValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArtifactValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArtifactValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArtifactValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArtifactValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArtifactValidationError) ErrorName() string { return "ArtifactValidationError" }

// Error satisfies the builtin error interface
func (e ArtifactValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArtifact.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArtifactValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArtifactValidationError{}

var _Artifact_Name_Pattern = regexp.MustCompile("^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$")

var _Artifact_DisplayName_Pattern = regexp.MustCompile("^\\PC*$")

var _Artifact_MimeType_Pattern = regexp.MustCompile("^(text/plain)$|^(application/json)$|^(application/yaml)$|^(image/png)$|^(image/jpeg)$")

// Validate checks the field values on Upload with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Upload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Upload with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UploadMultiError, or nil if none found.
func (m *Upload) ValidateAll() error {
	return m.validate(true)
}

func (m *Upload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileName

	// no validation rules for Artifact

	if len(errors) > 0 {
		return UploadMultiError(errors)
	}

	return nil
}

// UploadMultiError is an error wrapping multiple validation errors returned by
// Upload.ValidateAll() if the designated constraints aren't met.
type UploadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadMultiError) AllErrors() []error { return m }

// UploadValidationError is the validation error returned by Upload.Validate if
// the designated constraints aren't met.
type UploadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadValidationError) ErrorName() string { return "UploadValidationError" }

// Error satisfies the builtin error interface
func (e UploadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadValidationError{}
