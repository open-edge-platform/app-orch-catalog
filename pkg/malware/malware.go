// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

// Package malware provides an interface for using the clamav service to scan for malware.
package malware

import (
	"bytes"
	"encoding/binary"
	"net"
	"strings"
	"sync"
	"time"
)

const (
	// DefaultScannerTimeout is the default timeout to be used for scanning for malware.
	DefaultScannerTimeout = time.Duration(10) * time.Second
	DefaultPermissive     = false
)

var (
	MaxErrorRetries    = 5
	ErrorRetryInterval = 500 * time.Millisecond
)

type Scanner struct {
	address    string
	permissive bool // If true, do not block operations if malware-scanner is unavailable.
	conn       net.Conn
	timeout    time.Duration
	mu         sync.Mutex
}

func (m *Scanner) IsPermissive() bool {
	return m.permissive
}

func (m *Scanner) sendChunk(chunk []byte) error {
	chunkLenNB := make([]byte, 4)
	binary.BigEndian.PutUint32(chunkLenNB, uint32(len(chunk)))

	_, err := m.conn.Write(chunkLenNB)
	if err != nil {
		return err
	}

	_, err = m.conn.Write(chunk)
	if err != nil {
		return err
	}

	return nil
}

// ScanBytes scans a byte array for malware. It will return true if the file is okay,
// or it will return false if the file contains malware. If malware is detected, then
// a string will be returned indicating the nature of malware.
func (m *Scanner) ScanBytes(contents []byte) (bool, string, error) {
	var (
		ok       bool
		received string
		err      error
	)
	for i := 0; i < MaxErrorRetries; i++ {
		ok, received, err = m.scanBytes(contents)
		if err == nil {
			return ok, received, nil
		}
		time.Sleep(ErrorRetryInterval)
	}
	return ok, received, err
}

func (m *Scanner) scanBytes(contents []byte) (bool, string, error) {
	var err error
	m.mu.Lock()

	defer func() {
		if m.conn != nil {
			_ = m.conn.Close()
			m.conn = nil
		}
		m.mu.Unlock()
	}()

	dialer := &net.Dialer{Timeout: m.timeout}
	m.conn, err = dialer.Dial("tcp", m.address)

	if err != nil {
		return false, "", err
	}

	err = m.conn.SetDeadline(time.Now().Add(m.timeout))
	if err != nil {
		return false, "", err
	}

	// The clamav prototol is to send the following:
	//   "nINSTREAM"<null>
	//   One or more chunks of the form <length><data> where <length> is 32 bits in network byte order
	//   One chunk of length 0 to terminate the stream
	// Then we readback a result which will either contain "OK" or "FOUND"

	cmd := []byte("zINSTREAM")
	cmd = append(cmd, 0) // null is used as the terminator for the command
	_, err = m.conn.Write(cmd)
	if err != nil {
		return false, "", err
	}

	// Break chunks into a reasonable size when streaming to clamav

	for len(contents) > 1024 {
		err = m.sendChunk(contents[:1024])
		if err != nil {
			return false, "", err
		}
		contents = contents[1024:]
	}

	// We may have one leftover chunk

	if len(contents) > 0 {
		err = m.sendChunk(contents)
		if err != nil {
			return false, "", err
		}
	}

	//' Send a zero-length chunk to terminate the stream

	err = m.sendChunk([]byte{})
	if err != nil {
		return false, "", err
	}

	// Receive the response from the malware scanner

	received := make([]byte, 1024)
	_, err = m.conn.Read(received)
	if err != nil {
		return false, "", err
	}

	// eliminate trailing nulls
	received = bytes.Trim(received, "\x00")

	okay := (strings.Contains(string(received), "OK"))

	return okay, string(received), nil
}

// NewScanner creates a new Malware Scanner, and will contact
// calmav on the provided ip address:port.

func NewScanner(addr string, timeout time.Duration, permissive bool) *Scanner {
	m := &Scanner{address: addr, timeout: timeout, permissive: permissive}
	return m
}

// DefaultScanner. Expected to be created and configured from main().

var DefaultScanner *Scanner
