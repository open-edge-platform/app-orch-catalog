// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/application"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/applicationdependency"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/applicationnamespace"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/artifact"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/artifactreference"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/commonmixin"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/deploymentpackage"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/deploymentprofile"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/deploymentrequirement"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/endpoint"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/extension"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/ignoredresource"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/namespace"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/namespaceadornment"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/parametertemplate"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/predicate"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/profile"
	"github.com/open-edge-platform/app-orch-catalog/internal/ent/generated/registry"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplication           = "Application"
	TypeApplicationDependency = "ApplicationDependency"
	TypeApplicationNamespace  = "ApplicationNamespace"
	TypeArtifact              = "Artifact"
	TypeArtifactReference     = "ArtifactReference"
	TypeCommonMixin           = "CommonMixin"
	TypeDeploymentPackage     = "DeploymentPackage"
	TypeDeploymentProfile     = "DeploymentProfile"
	TypeDeploymentRequirement = "DeploymentRequirement"
	TypeEndpoint              = "Endpoint"
	TypeExtension             = "Extension"
	TypeIgnoredResource       = "IgnoredResource"
	TypeNamespace             = "Namespace"
	TypeNamespaceAdornment    = "NamespaceAdornment"
	TypeParameterTemplate     = "ParameterTemplate"
	TypeProfile               = "Profile"
	TypeRegistry              = "Registry"
)

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	name                         *string
	display_name                 *string
	display_name_lc              *string
	description                  *string
	create_time                  *time.Time
	update_time                  *time.Time
	project_uuid                 *string
	version                      *string
	chart_name                   *string
	chart_version                *string
	kind                         *string
	clearedFields                map[string]struct{}
	profiles                     map[uint64]struct{}
	removedprofiles              map[uint64]struct{}
	clearedprofiles              bool
	registry_fk                  *uint64
	clearedregistry_fk           bool
	image_registry_fk            *uint64
	clearedimage_registry_fk     bool
	deployment_package_fk        map[uint64]struct{}
	removeddeployment_package_fk map[uint64]struct{}
	cleareddeployment_package_fk bool
	dependency_source_fk         map[uint64]struct{}
	removeddependency_source_fk  map[uint64]struct{}
	cleareddependency_source_fk  bool
	dependency_target_fk         map[uint64]struct{}
	removeddependency_target_fk  map[uint64]struct{}
	cleareddependency_target_fk  bool
	default_profile              *uint64
	cleareddefault_profile       bool
	ignored_resources            map[uint64]struct{}
	removedignored_resources     map[uint64]struct{}
	clearedignored_resources     bool
	done                         bool
	oldValue                     func(context.Context) (*Application, error)
	predicates                   []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id uint64) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApplicationMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ApplicationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ApplicationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ApplicationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[application.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ApplicationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[application.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ApplicationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, application.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *ApplicationMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *ApplicationMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *ApplicationMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[application.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *ApplicationMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[application.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *ApplicationMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, application.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *ApplicationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApplicationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ApplicationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[application.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ApplicationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[application.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ApplicationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, application.FieldDescription)
}

// SetCreateTime sets the "create_time" field.
func (m *ApplicationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ApplicationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ApplicationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ApplicationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ApplicationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ApplicationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectUUID sets the "project_uuid" field.
func (m *ApplicationMutation) SetProjectUUID(s string) {
	m.project_uuid = &s
}

// ProjectUUID returns the value of the "project_uuid" field in the mutation.
func (m *ApplicationMutation) ProjectUUID() (r string, exists bool) {
	v := m.project_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectUUID returns the old "project_uuid" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldProjectUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectUUID: %w", err)
	}
	return oldValue.ProjectUUID, nil
}

// ResetProjectUUID resets all changes to the "project_uuid" field.
func (m *ApplicationMutation) ResetProjectUUID() {
	m.project_uuid = nil
}

// SetVersion sets the "version" field.
func (m *ApplicationMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ApplicationMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ApplicationMutation) ResetVersion() {
	m.version = nil
}

// SetChartName sets the "chart_name" field.
func (m *ApplicationMutation) SetChartName(s string) {
	m.chart_name = &s
}

// ChartName returns the value of the "chart_name" field in the mutation.
func (m *ApplicationMutation) ChartName() (r string, exists bool) {
	v := m.chart_name
	if v == nil {
		return
	}
	return *v, true
}

// OldChartName returns the old "chart_name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldChartName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChartName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChartName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChartName: %w", err)
	}
	return oldValue.ChartName, nil
}

// ResetChartName resets all changes to the "chart_name" field.
func (m *ApplicationMutation) ResetChartName() {
	m.chart_name = nil
}

// SetChartVersion sets the "chart_version" field.
func (m *ApplicationMutation) SetChartVersion(s string) {
	m.chart_version = &s
}

// ChartVersion returns the value of the "chart_version" field in the mutation.
func (m *ApplicationMutation) ChartVersion() (r string, exists bool) {
	v := m.chart_version
	if v == nil {
		return
	}
	return *v, true
}

// OldChartVersion returns the old "chart_version" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldChartVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChartVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChartVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChartVersion: %w", err)
	}
	return oldValue.ChartVersion, nil
}

// ResetChartVersion resets all changes to the "chart_version" field.
func (m *ApplicationMutation) ResetChartVersion() {
	m.chart_version = nil
}

// SetKind sets the "kind" field.
func (m *ApplicationMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *ApplicationMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *ApplicationMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[application.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *ApplicationMutation) KindCleared() bool {
	_, ok := m.clearedFields[application.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *ApplicationMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, application.FieldKind)
}

// AddProfileIDs adds the "profiles" edge to the Profile entity by ids.
func (m *ApplicationMutation) AddProfileIDs(ids ...uint64) {
	if m.profiles == nil {
		m.profiles = make(map[uint64]struct{})
	}
	for i := range ids {
		m.profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "profiles" edge to the Profile entity.
func (m *ApplicationMutation) ClearProfiles() {
	m.clearedprofiles = true
}

// ProfilesCleared reports if the "profiles" edge to the Profile entity was cleared.
func (m *ApplicationMutation) ProfilesCleared() bool {
	return m.clearedprofiles
}

// RemoveProfileIDs removes the "profiles" edge to the Profile entity by IDs.
func (m *ApplicationMutation) RemoveProfileIDs(ids ...uint64) {
	if m.removedprofiles == nil {
		m.removedprofiles = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.profiles, ids[i])
		m.removedprofiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "profiles" edge to the Profile entity.
func (m *ApplicationMutation) RemovedProfilesIDs() (ids []uint64) {
	for id := range m.removedprofiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "profiles" edge IDs in the mutation.
func (m *ApplicationMutation) ProfilesIDs() (ids []uint64) {
	for id := range m.profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "profiles" edge.
func (m *ApplicationMutation) ResetProfiles() {
	m.profiles = nil
	m.clearedprofiles = false
	m.removedprofiles = nil
}

// SetRegistryFkID sets the "registry_fk" edge to the Registry entity by id.
func (m *ApplicationMutation) SetRegistryFkID(id uint64) {
	m.registry_fk = &id
}

// ClearRegistryFk clears the "registry_fk" edge to the Registry entity.
func (m *ApplicationMutation) ClearRegistryFk() {
	m.clearedregistry_fk = true
}

// RegistryFkCleared reports if the "registry_fk" edge to the Registry entity was cleared.
func (m *ApplicationMutation) RegistryFkCleared() bool {
	return m.clearedregistry_fk
}

// RegistryFkID returns the "registry_fk" edge ID in the mutation.
func (m *ApplicationMutation) RegistryFkID() (id uint64, exists bool) {
	if m.registry_fk != nil {
		return *m.registry_fk, true
	}
	return
}

// RegistryFkIDs returns the "registry_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegistryFkID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) RegistryFkIDs() (ids []uint64) {
	if id := m.registry_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegistryFk resets all changes to the "registry_fk" edge.
func (m *ApplicationMutation) ResetRegistryFk() {
	m.registry_fk = nil
	m.clearedregistry_fk = false
}

// SetImageRegistryFkID sets the "image_registry_fk" edge to the Registry entity by id.
func (m *ApplicationMutation) SetImageRegistryFkID(id uint64) {
	m.image_registry_fk = &id
}

// ClearImageRegistryFk clears the "image_registry_fk" edge to the Registry entity.
func (m *ApplicationMutation) ClearImageRegistryFk() {
	m.clearedimage_registry_fk = true
}

// ImageRegistryFkCleared reports if the "image_registry_fk" edge to the Registry entity was cleared.
func (m *ApplicationMutation) ImageRegistryFkCleared() bool {
	return m.clearedimage_registry_fk
}

// ImageRegistryFkID returns the "image_registry_fk" edge ID in the mutation.
func (m *ApplicationMutation) ImageRegistryFkID() (id uint64, exists bool) {
	if m.image_registry_fk != nil {
		return *m.image_registry_fk, true
	}
	return
}

// ImageRegistryFkIDs returns the "image_registry_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageRegistryFkID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ImageRegistryFkIDs() (ids []uint64) {
	if id := m.image_registry_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImageRegistryFk resets all changes to the "image_registry_fk" edge.
func (m *ApplicationMutation) ResetImageRegistryFk() {
	m.image_registry_fk = nil
	m.clearedimage_registry_fk = false
}

// AddDeploymentPackageFkIDs adds the "deployment_package_fk" edge to the DeploymentPackage entity by ids.
func (m *ApplicationMutation) AddDeploymentPackageFkIDs(ids ...uint64) {
	if m.deployment_package_fk == nil {
		m.deployment_package_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		m.deployment_package_fk[ids[i]] = struct{}{}
	}
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *ApplicationMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *ApplicationMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// RemoveDeploymentPackageFkIDs removes the "deployment_package_fk" edge to the DeploymentPackage entity by IDs.
func (m *ApplicationMutation) RemoveDeploymentPackageFkIDs(ids ...uint64) {
	if m.removeddeployment_package_fk == nil {
		m.removeddeployment_package_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.deployment_package_fk, ids[i])
		m.removeddeployment_package_fk[ids[i]] = struct{}{}
	}
}

// RemovedDeploymentPackageFk returns the removed IDs of the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *ApplicationMutation) RemovedDeploymentPackageFkIDs() (ids []uint64) {
	for id := range m.removeddeployment_package_fk {
		ids = append(ids, id)
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
func (m *ApplicationMutation) DeploymentPackageFkIDs() (ids []uint64) {
	for id := range m.deployment_package_fk {
		ids = append(ids, id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *ApplicationMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
	m.removeddeployment_package_fk = nil
}

// AddDependencySourceFkIDs adds the "dependency_source_fk" edge to the ApplicationDependency entity by ids.
func (m *ApplicationMutation) AddDependencySourceFkIDs(ids ...uint64) {
	if m.dependency_source_fk == nil {
		m.dependency_source_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		m.dependency_source_fk[ids[i]] = struct{}{}
	}
}

// ClearDependencySourceFk clears the "dependency_source_fk" edge to the ApplicationDependency entity.
func (m *ApplicationMutation) ClearDependencySourceFk() {
	m.cleareddependency_source_fk = true
}

// DependencySourceFkCleared reports if the "dependency_source_fk" edge to the ApplicationDependency entity was cleared.
func (m *ApplicationMutation) DependencySourceFkCleared() bool {
	return m.cleareddependency_source_fk
}

// RemoveDependencySourceFkIDs removes the "dependency_source_fk" edge to the ApplicationDependency entity by IDs.
func (m *ApplicationMutation) RemoveDependencySourceFkIDs(ids ...uint64) {
	if m.removeddependency_source_fk == nil {
		m.removeddependency_source_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.dependency_source_fk, ids[i])
		m.removeddependency_source_fk[ids[i]] = struct{}{}
	}
}

// RemovedDependencySourceFk returns the removed IDs of the "dependency_source_fk" edge to the ApplicationDependency entity.
func (m *ApplicationMutation) RemovedDependencySourceFkIDs() (ids []uint64) {
	for id := range m.removeddependency_source_fk {
		ids = append(ids, id)
	}
	return
}

// DependencySourceFkIDs returns the "dependency_source_fk" edge IDs in the mutation.
func (m *ApplicationMutation) DependencySourceFkIDs() (ids []uint64) {
	for id := range m.dependency_source_fk {
		ids = append(ids, id)
	}
	return
}

// ResetDependencySourceFk resets all changes to the "dependency_source_fk" edge.
func (m *ApplicationMutation) ResetDependencySourceFk() {
	m.dependency_source_fk = nil
	m.cleareddependency_source_fk = false
	m.removeddependency_source_fk = nil
}

// AddDependencyTargetFkIDs adds the "dependency_target_fk" edge to the ApplicationDependency entity by ids.
func (m *ApplicationMutation) AddDependencyTargetFkIDs(ids ...uint64) {
	if m.dependency_target_fk == nil {
		m.dependency_target_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		m.dependency_target_fk[ids[i]] = struct{}{}
	}
}

// ClearDependencyTargetFk clears the "dependency_target_fk" edge to the ApplicationDependency entity.
func (m *ApplicationMutation) ClearDependencyTargetFk() {
	m.cleareddependency_target_fk = true
}

// DependencyTargetFkCleared reports if the "dependency_target_fk" edge to the ApplicationDependency entity was cleared.
func (m *ApplicationMutation) DependencyTargetFkCleared() bool {
	return m.cleareddependency_target_fk
}

// RemoveDependencyTargetFkIDs removes the "dependency_target_fk" edge to the ApplicationDependency entity by IDs.
func (m *ApplicationMutation) RemoveDependencyTargetFkIDs(ids ...uint64) {
	if m.removeddependency_target_fk == nil {
		m.removeddependency_target_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.dependency_target_fk, ids[i])
		m.removeddependency_target_fk[ids[i]] = struct{}{}
	}
}

// RemovedDependencyTargetFk returns the removed IDs of the "dependency_target_fk" edge to the ApplicationDependency entity.
func (m *ApplicationMutation) RemovedDependencyTargetFkIDs() (ids []uint64) {
	for id := range m.removeddependency_target_fk {
		ids = append(ids, id)
	}
	return
}

// DependencyTargetFkIDs returns the "dependency_target_fk" edge IDs in the mutation.
func (m *ApplicationMutation) DependencyTargetFkIDs() (ids []uint64) {
	for id := range m.dependency_target_fk {
		ids = append(ids, id)
	}
	return
}

// ResetDependencyTargetFk resets all changes to the "dependency_target_fk" edge.
func (m *ApplicationMutation) ResetDependencyTargetFk() {
	m.dependency_target_fk = nil
	m.cleareddependency_target_fk = false
	m.removeddependency_target_fk = nil
}

// SetDefaultProfileID sets the "default_profile" edge to the Profile entity by id.
func (m *ApplicationMutation) SetDefaultProfileID(id uint64) {
	m.default_profile = &id
}

// ClearDefaultProfile clears the "default_profile" edge to the Profile entity.
func (m *ApplicationMutation) ClearDefaultProfile() {
	m.cleareddefault_profile = true
}

// DefaultProfileCleared reports if the "default_profile" edge to the Profile entity was cleared.
func (m *ApplicationMutation) DefaultProfileCleared() bool {
	return m.cleareddefault_profile
}

// DefaultProfileID returns the "default_profile" edge ID in the mutation.
func (m *ApplicationMutation) DefaultProfileID() (id uint64, exists bool) {
	if m.default_profile != nil {
		return *m.default_profile, true
	}
	return
}

// DefaultProfileIDs returns the "default_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultProfileID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) DefaultProfileIDs() (ids []uint64) {
	if id := m.default_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultProfile resets all changes to the "default_profile" edge.
func (m *ApplicationMutation) ResetDefaultProfile() {
	m.default_profile = nil
	m.cleareddefault_profile = false
}

// AddIgnoredResourceIDs adds the "ignored_resources" edge to the IgnoredResource entity by ids.
func (m *ApplicationMutation) AddIgnoredResourceIDs(ids ...uint64) {
	if m.ignored_resources == nil {
		m.ignored_resources = make(map[uint64]struct{})
	}
	for i := range ids {
		m.ignored_resources[ids[i]] = struct{}{}
	}
}

// ClearIgnoredResources clears the "ignored_resources" edge to the IgnoredResource entity.
func (m *ApplicationMutation) ClearIgnoredResources() {
	m.clearedignored_resources = true
}

// IgnoredResourcesCleared reports if the "ignored_resources" edge to the IgnoredResource entity was cleared.
func (m *ApplicationMutation) IgnoredResourcesCleared() bool {
	return m.clearedignored_resources
}

// RemoveIgnoredResourceIDs removes the "ignored_resources" edge to the IgnoredResource entity by IDs.
func (m *ApplicationMutation) RemoveIgnoredResourceIDs(ids ...uint64) {
	if m.removedignored_resources == nil {
		m.removedignored_resources = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.ignored_resources, ids[i])
		m.removedignored_resources[ids[i]] = struct{}{}
	}
}

// RemovedIgnoredResources returns the removed IDs of the "ignored_resources" edge to the IgnoredResource entity.
func (m *ApplicationMutation) RemovedIgnoredResourcesIDs() (ids []uint64) {
	for id := range m.removedignored_resources {
		ids = append(ids, id)
	}
	return
}

// IgnoredResourcesIDs returns the "ignored_resources" edge IDs in the mutation.
func (m *ApplicationMutation) IgnoredResourcesIDs() (ids []uint64) {
	for id := range m.ignored_resources {
		ids = append(ids, id)
	}
	return
}

// ResetIgnoredResources resets all changes to the "ignored_resources" edge.
func (m *ApplicationMutation) ResetIgnoredResources() {
	m.ignored_resources = nil
	m.clearedignored_resources = false
	m.removedignored_resources = nil
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, application.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, application.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, application.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, application.FieldDescription)
	}
	if m.create_time != nil {
		fields = append(fields, application.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, application.FieldUpdateTime)
	}
	if m.project_uuid != nil {
		fields = append(fields, application.FieldProjectUUID)
	}
	if m.version != nil {
		fields = append(fields, application.FieldVersion)
	}
	if m.chart_name != nil {
		fields = append(fields, application.FieldChartName)
	}
	if m.chart_version != nil {
		fields = append(fields, application.FieldChartVersion)
	}
	if m.kind != nil {
		fields = append(fields, application.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldName:
		return m.Name()
	case application.FieldDisplayName:
		return m.DisplayName()
	case application.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case application.FieldDescription:
		return m.Description()
	case application.FieldCreateTime:
		return m.CreateTime()
	case application.FieldUpdateTime:
		return m.UpdateTime()
	case application.FieldProjectUUID:
		return m.ProjectUUID()
	case application.FieldVersion:
		return m.Version()
	case application.FieldChartName:
		return m.ChartName()
	case application.FieldChartVersion:
		return m.ChartVersion()
	case application.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldName:
		return m.OldName(ctx)
	case application.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case application.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case application.FieldDescription:
		return m.OldDescription(ctx)
	case application.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case application.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case application.FieldProjectUUID:
		return m.OldProjectUUID(ctx)
	case application.FieldVersion:
		return m.OldVersion(ctx)
	case application.FieldChartName:
		return m.OldChartName(ctx)
	case application.FieldChartVersion:
		return m.OldChartVersion(ctx)
	case application.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case application.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case application.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case application.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case application.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case application.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case application.FieldProjectUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectUUID(v)
		return nil
	case application.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case application.FieldChartName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChartName(v)
		return nil
	case application.FieldChartVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChartVersion(v)
		return nil
	case application.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldDisplayName) {
		fields = append(fields, application.FieldDisplayName)
	}
	if m.FieldCleared(application.FieldDisplayNameLc) {
		fields = append(fields, application.FieldDisplayNameLc)
	}
	if m.FieldCleared(application.FieldDescription) {
		fields = append(fields, application.FieldDescription)
	}
	if m.FieldCleared(application.FieldKind) {
		fields = append(fields, application.FieldKind)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case application.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case application.FieldDescription:
		m.ClearDescription()
		return nil
	case application.FieldKind:
		m.ClearKind()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldName:
		m.ResetName()
		return nil
	case application.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case application.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case application.FieldDescription:
		m.ResetDescription()
		return nil
	case application.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case application.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case application.FieldProjectUUID:
		m.ResetProjectUUID()
		return nil
	case application.FieldVersion:
		m.ResetVersion()
		return nil
	case application.FieldChartName:
		m.ResetChartName()
		return nil
	case application.FieldChartVersion:
		m.ResetChartVersion()
		return nil
	case application.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.profiles != nil {
		edges = append(edges, application.EdgeProfiles)
	}
	if m.registry_fk != nil {
		edges = append(edges, application.EdgeRegistryFk)
	}
	if m.image_registry_fk != nil {
		edges = append(edges, application.EdgeImageRegistryFk)
	}
	if m.deployment_package_fk != nil {
		edges = append(edges, application.EdgeDeploymentPackageFk)
	}
	if m.dependency_source_fk != nil {
		edges = append(edges, application.EdgeDependencySourceFk)
	}
	if m.dependency_target_fk != nil {
		edges = append(edges, application.EdgeDependencyTargetFk)
	}
	if m.default_profile != nil {
		edges = append(edges, application.EdgeDefaultProfile)
	}
	if m.ignored_resources != nil {
		edges = append(edges, application.EdgeIgnoredResources)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.profiles))
		for id := range m.profiles {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeRegistryFk:
		if id := m.registry_fk; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeImageRegistryFk:
		if id := m.image_registry_fk; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeDeploymentPackageFk:
		ids := make([]ent.Value, 0, len(m.deployment_package_fk))
		for id := range m.deployment_package_fk {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeDependencySourceFk:
		ids := make([]ent.Value, 0, len(m.dependency_source_fk))
		for id := range m.dependency_source_fk {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeDependencyTargetFk:
		ids := make([]ent.Value, 0, len(m.dependency_target_fk))
		for id := range m.dependency_target_fk {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeDefaultProfile:
		if id := m.default_profile; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeIgnoredResources:
		ids := make([]ent.Value, 0, len(m.ignored_resources))
		for id := range m.ignored_resources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedprofiles != nil {
		edges = append(edges, application.EdgeProfiles)
	}
	if m.removeddeployment_package_fk != nil {
		edges = append(edges, application.EdgeDeploymentPackageFk)
	}
	if m.removeddependency_source_fk != nil {
		edges = append(edges, application.EdgeDependencySourceFk)
	}
	if m.removeddependency_target_fk != nil {
		edges = append(edges, application.EdgeDependencyTargetFk)
	}
	if m.removedignored_resources != nil {
		edges = append(edges, application.EdgeIgnoredResources)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removedprofiles))
		for id := range m.removedprofiles {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeDeploymentPackageFk:
		ids := make([]ent.Value, 0, len(m.removeddeployment_package_fk))
		for id := range m.removeddeployment_package_fk {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeDependencySourceFk:
		ids := make([]ent.Value, 0, len(m.removeddependency_source_fk))
		for id := range m.removeddependency_source_fk {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeDependencyTargetFk:
		ids := make([]ent.Value, 0, len(m.removeddependency_target_fk))
		for id := range m.removeddependency_target_fk {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeIgnoredResources:
		ids := make([]ent.Value, 0, len(m.removedignored_resources))
		for id := range m.removedignored_resources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedprofiles {
		edges = append(edges, application.EdgeProfiles)
	}
	if m.clearedregistry_fk {
		edges = append(edges, application.EdgeRegistryFk)
	}
	if m.clearedimage_registry_fk {
		edges = append(edges, application.EdgeImageRegistryFk)
	}
	if m.cleareddeployment_package_fk {
		edges = append(edges, application.EdgeDeploymentPackageFk)
	}
	if m.cleareddependency_source_fk {
		edges = append(edges, application.EdgeDependencySourceFk)
	}
	if m.cleareddependency_target_fk {
		edges = append(edges, application.EdgeDependencyTargetFk)
	}
	if m.cleareddefault_profile {
		edges = append(edges, application.EdgeDefaultProfile)
	}
	if m.clearedignored_resources {
		edges = append(edges, application.EdgeIgnoredResources)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeProfiles:
		return m.clearedprofiles
	case application.EdgeRegistryFk:
		return m.clearedregistry_fk
	case application.EdgeImageRegistryFk:
		return m.clearedimage_registry_fk
	case application.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	case application.EdgeDependencySourceFk:
		return m.cleareddependency_source_fk
	case application.EdgeDependencyTargetFk:
		return m.cleareddependency_target_fk
	case application.EdgeDefaultProfile:
		return m.cleareddefault_profile
	case application.EdgeIgnoredResources:
		return m.clearedignored_resources
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeRegistryFk:
		m.ClearRegistryFk()
		return nil
	case application.EdgeImageRegistryFk:
		m.ClearImageRegistryFk()
		return nil
	case application.EdgeDefaultProfile:
		m.ClearDefaultProfile()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeProfiles:
		m.ResetProfiles()
		return nil
	case application.EdgeRegistryFk:
		m.ResetRegistryFk()
		return nil
	case application.EdgeImageRegistryFk:
		m.ResetImageRegistryFk()
		return nil
	case application.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	case application.EdgeDependencySourceFk:
		m.ResetDependencySourceFk()
		return nil
	case application.EdgeDependencyTargetFk:
		m.ResetDependencyTargetFk()
		return nil
	case application.EdgeDefaultProfile:
		m.ResetDefaultProfile()
		return nil
	case application.EdgeIgnoredResources:
		m.ResetIgnoredResources()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// ApplicationDependencyMutation represents an operation that mutates the ApplicationDependency nodes in the graph.
type ApplicationDependencyMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	clearedFields                map[string]struct{}
	deployment_package_fk        *uint64
	cleareddeployment_package_fk bool
	source_fk                    *uint64
	clearedsource_fk             bool
	target_fk                    *uint64
	clearedtarget_fk             bool
	done                         bool
	oldValue                     func(context.Context) (*ApplicationDependency, error)
	predicates                   []predicate.ApplicationDependency
}

var _ ent.Mutation = (*ApplicationDependencyMutation)(nil)

// applicationdependencyOption allows management of the mutation configuration using functional options.
type applicationdependencyOption func(*ApplicationDependencyMutation)

// newApplicationDependencyMutation creates new mutation for the ApplicationDependency entity.
func newApplicationDependencyMutation(c config, op Op, opts ...applicationdependencyOption) *ApplicationDependencyMutation {
	m := &ApplicationDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicationDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationDependencyID sets the ID field of the mutation.
func withApplicationDependencyID(id uint64) applicationdependencyOption {
	return func(m *ApplicationDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplicationDependency
		)
		m.oldValue = func(ctx context.Context) (*ApplicationDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplicationDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicationDependency sets the old ApplicationDependency of the mutation.
func withApplicationDependency(node *ApplicationDependency) applicationdependencyOption {
	return func(m *ApplicationDependencyMutation) {
		m.oldValue = func(context.Context) (*ApplicationDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationDependencyMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationDependencyMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplicationDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeploymentPackageFkID sets the "deployment_package_fk" edge to the DeploymentPackage entity by id.
func (m *ApplicationDependencyMutation) SetDeploymentPackageFkID(id uint64) {
	m.deployment_package_fk = &id
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *ApplicationDependencyMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *ApplicationDependencyMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// DeploymentPackageFkID returns the "deployment_package_fk" edge ID in the mutation.
func (m *ApplicationDependencyMutation) DeploymentPackageFkID() (id uint64, exists bool) {
	if m.deployment_package_fk != nil {
		return *m.deployment_package_fk, true
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentPackageFkID instead. It exists only for internal usage by the builders.
func (m *ApplicationDependencyMutation) DeploymentPackageFkIDs() (ids []uint64) {
	if id := m.deployment_package_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *ApplicationDependencyMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
}

// SetSourceFkID sets the "source_fk" edge to the Application entity by id.
func (m *ApplicationDependencyMutation) SetSourceFkID(id uint64) {
	m.source_fk = &id
}

// ClearSourceFk clears the "source_fk" edge to the Application entity.
func (m *ApplicationDependencyMutation) ClearSourceFk() {
	m.clearedsource_fk = true
}

// SourceFkCleared reports if the "source_fk" edge to the Application entity was cleared.
func (m *ApplicationDependencyMutation) SourceFkCleared() bool {
	return m.clearedsource_fk
}

// SourceFkID returns the "source_fk" edge ID in the mutation.
func (m *ApplicationDependencyMutation) SourceFkID() (id uint64, exists bool) {
	if m.source_fk != nil {
		return *m.source_fk, true
	}
	return
}

// SourceFkIDs returns the "source_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceFkID instead. It exists only for internal usage by the builders.
func (m *ApplicationDependencyMutation) SourceFkIDs() (ids []uint64) {
	if id := m.source_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceFk resets all changes to the "source_fk" edge.
func (m *ApplicationDependencyMutation) ResetSourceFk() {
	m.source_fk = nil
	m.clearedsource_fk = false
}

// SetTargetFkID sets the "target_fk" edge to the Application entity by id.
func (m *ApplicationDependencyMutation) SetTargetFkID(id uint64) {
	m.target_fk = &id
}

// ClearTargetFk clears the "target_fk" edge to the Application entity.
func (m *ApplicationDependencyMutation) ClearTargetFk() {
	m.clearedtarget_fk = true
}

// TargetFkCleared reports if the "target_fk" edge to the Application entity was cleared.
func (m *ApplicationDependencyMutation) TargetFkCleared() bool {
	return m.clearedtarget_fk
}

// TargetFkID returns the "target_fk" edge ID in the mutation.
func (m *ApplicationDependencyMutation) TargetFkID() (id uint64, exists bool) {
	if m.target_fk != nil {
		return *m.target_fk, true
	}
	return
}

// TargetFkIDs returns the "target_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetFkID instead. It exists only for internal usage by the builders.
func (m *ApplicationDependencyMutation) TargetFkIDs() (ids []uint64) {
	if id := m.target_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetFk resets all changes to the "target_fk" edge.
func (m *ApplicationDependencyMutation) ResetTargetFk() {
	m.target_fk = nil
	m.clearedtarget_fk = false
}

// Where appends a list predicates to the ApplicationDependencyMutation builder.
func (m *ApplicationDependencyMutation) Where(ps ...predicate.ApplicationDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplicationDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplicationDependency).
func (m *ApplicationDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationDependencyMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationDependencyMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ApplicationDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApplicationDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationDependencyMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ApplicationDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApplicationDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationDependencyMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ApplicationDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.deployment_package_fk != nil {
		edges = append(edges, applicationdependency.EdgeDeploymentPackageFk)
	}
	if m.source_fk != nil {
		edges = append(edges, applicationdependency.EdgeSourceFk)
	}
	if m.target_fk != nil {
		edges = append(edges, applicationdependency.EdgeTargetFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case applicationdependency.EdgeDeploymentPackageFk:
		if id := m.deployment_package_fk; id != nil {
			return []ent.Value{*id}
		}
	case applicationdependency.EdgeSourceFk:
		if id := m.source_fk; id != nil {
			return []ent.Value{*id}
		}
	case applicationdependency.EdgeTargetFk:
		if id := m.target_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddeployment_package_fk {
		edges = append(edges, applicationdependency.EdgeDeploymentPackageFk)
	}
	if m.clearedsource_fk {
		edges = append(edges, applicationdependency.EdgeSourceFk)
	}
	if m.clearedtarget_fk {
		edges = append(edges, applicationdependency.EdgeTargetFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case applicationdependency.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	case applicationdependency.EdgeSourceFk:
		return m.clearedsource_fk
	case applicationdependency.EdgeTargetFk:
		return m.clearedtarget_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationDependencyMutation) ClearEdge(name string) error {
	switch name {
	case applicationdependency.EdgeDeploymentPackageFk:
		m.ClearDeploymentPackageFk()
		return nil
	case applicationdependency.EdgeSourceFk:
		m.ClearSourceFk()
		return nil
	case applicationdependency.EdgeTargetFk:
		m.ClearTargetFk()
		return nil
	}
	return fmt.Errorf("unknown ApplicationDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationDependencyMutation) ResetEdge(name string) error {
	switch name {
	case applicationdependency.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	case applicationdependency.EdgeSourceFk:
		m.ResetSourceFk()
		return nil
	case applicationdependency.EdgeTargetFk:
		m.ResetTargetFk()
		return nil
	}
	return fmt.Errorf("unknown ApplicationDependency edge %s", name)
}

// ApplicationNamespaceMutation represents an operation that mutates the ApplicationNamespace nodes in the graph.
type ApplicationNamespaceMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	namespace                    *string
	clearedFields                map[string]struct{}
	deployment_package_fk        *uint64
	cleareddeployment_package_fk bool
	source_fk                    *uint64
	clearedsource_fk             bool
	done                         bool
	oldValue                     func(context.Context) (*ApplicationNamespace, error)
	predicates                   []predicate.ApplicationNamespace
}

var _ ent.Mutation = (*ApplicationNamespaceMutation)(nil)

// applicationnamespaceOption allows management of the mutation configuration using functional options.
type applicationnamespaceOption func(*ApplicationNamespaceMutation)

// newApplicationNamespaceMutation creates new mutation for the ApplicationNamespace entity.
func newApplicationNamespaceMutation(c config, op Op, opts ...applicationnamespaceOption) *ApplicationNamespaceMutation {
	m := &ApplicationNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicationNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationNamespaceID sets the ID field of the mutation.
func withApplicationNamespaceID(id uint64) applicationnamespaceOption {
	return func(m *ApplicationNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplicationNamespace
		)
		m.oldValue = func(ctx context.Context) (*ApplicationNamespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplicationNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicationNamespace sets the old ApplicationNamespace of the mutation.
func withApplicationNamespace(node *ApplicationNamespace) applicationnamespaceOption {
	return func(m *ApplicationNamespaceMutation) {
		m.oldValue = func(context.Context) (*ApplicationNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationNamespaceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationNamespaceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplicationNamespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *ApplicationNamespaceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *ApplicationNamespaceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the ApplicationNamespace entity.
// If the ApplicationNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationNamespaceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *ApplicationNamespaceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetDeploymentPackageFkID sets the "deployment_package_fk" edge to the DeploymentPackage entity by id.
func (m *ApplicationNamespaceMutation) SetDeploymentPackageFkID(id uint64) {
	m.deployment_package_fk = &id
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *ApplicationNamespaceMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *ApplicationNamespaceMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// DeploymentPackageFkID returns the "deployment_package_fk" edge ID in the mutation.
func (m *ApplicationNamespaceMutation) DeploymentPackageFkID() (id uint64, exists bool) {
	if m.deployment_package_fk != nil {
		return *m.deployment_package_fk, true
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentPackageFkID instead. It exists only for internal usage by the builders.
func (m *ApplicationNamespaceMutation) DeploymentPackageFkIDs() (ids []uint64) {
	if id := m.deployment_package_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *ApplicationNamespaceMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
}

// SetSourceFkID sets the "source_fk" edge to the Application entity by id.
func (m *ApplicationNamespaceMutation) SetSourceFkID(id uint64) {
	m.source_fk = &id
}

// ClearSourceFk clears the "source_fk" edge to the Application entity.
func (m *ApplicationNamespaceMutation) ClearSourceFk() {
	m.clearedsource_fk = true
}

// SourceFkCleared reports if the "source_fk" edge to the Application entity was cleared.
func (m *ApplicationNamespaceMutation) SourceFkCleared() bool {
	return m.clearedsource_fk
}

// SourceFkID returns the "source_fk" edge ID in the mutation.
func (m *ApplicationNamespaceMutation) SourceFkID() (id uint64, exists bool) {
	if m.source_fk != nil {
		return *m.source_fk, true
	}
	return
}

// SourceFkIDs returns the "source_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceFkID instead. It exists only for internal usage by the builders.
func (m *ApplicationNamespaceMutation) SourceFkIDs() (ids []uint64) {
	if id := m.source_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceFk resets all changes to the "source_fk" edge.
func (m *ApplicationNamespaceMutation) ResetSourceFk() {
	m.source_fk = nil
	m.clearedsource_fk = false
}

// Where appends a list predicates to the ApplicationNamespaceMutation builder.
func (m *ApplicationNamespaceMutation) Where(ps ...predicate.ApplicationNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationNamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationNamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplicationNamespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationNamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationNamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplicationNamespace).
func (m *ApplicationNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.namespace != nil {
		fields = append(fields, applicationnamespace.FieldNamespace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applicationnamespace.FieldNamespace:
		return m.Namespace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applicationnamespace.FieldNamespace:
		return m.OldNamespace(ctx)
	}
	return nil, fmt.Errorf("unknown ApplicationNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applicationnamespace.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	}
	return fmt.Errorf("unknown ApplicationNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationNamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApplicationNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApplicationNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationNamespaceMutation) ResetField(name string) error {
	switch name {
	case applicationnamespace.FieldNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown ApplicationNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.deployment_package_fk != nil {
		edges = append(edges, applicationnamespace.EdgeDeploymentPackageFk)
	}
	if m.source_fk != nil {
		edges = append(edges, applicationnamespace.EdgeSourceFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationNamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case applicationnamespace.EdgeDeploymentPackageFk:
		if id := m.deployment_package_fk; id != nil {
			return []ent.Value{*id}
		}
	case applicationnamespace.EdgeSourceFk:
		if id := m.source_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationNamespaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeployment_package_fk {
		edges = append(edges, applicationnamespace.EdgeDeploymentPackageFk)
	}
	if m.clearedsource_fk {
		edges = append(edges, applicationnamespace.EdgeSourceFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationNamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case applicationnamespace.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	case applicationnamespace.EdgeSourceFk:
		return m.clearedsource_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationNamespaceMutation) ClearEdge(name string) error {
	switch name {
	case applicationnamespace.EdgeDeploymentPackageFk:
		m.ClearDeploymentPackageFk()
		return nil
	case applicationnamespace.EdgeSourceFk:
		m.ClearSourceFk()
		return nil
	}
	return fmt.Errorf("unknown ApplicationNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationNamespaceMutation) ResetEdge(name string) error {
	switch name {
	case applicationnamespace.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	case applicationnamespace.EdgeSourceFk:
		m.ResetSourceFk()
		return nil
	}
	return fmt.Errorf("unknown ApplicationNamespace edge %s", name)
}

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint64
	name                   *string
	display_name           *string
	display_name_lc        *string
	description            *string
	create_time            *time.Time
	update_time            *time.Time
	project_uuid           *string
	mime_type              *string
	artifact               *[]byte
	clearedFields          map[string]struct{}
	ca_icon_fk             map[uint64]struct{}
	removedca_icon_fk      map[uint64]struct{}
	clearedca_icon_fk      bool
	ca_thumbnail_fk        map[uint64]struct{}
	removedca_thumbnail_fk map[uint64]struct{}
	clearedca_thumbnail_fk bool
	done                   bool
	oldValue               func(context.Context) (*Artifact, error)
	predicates             []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id uint64) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ArtifactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtifactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtifactMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ArtifactMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ArtifactMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ArtifactMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[artifact.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ArtifactMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ArtifactMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, artifact.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *ArtifactMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *ArtifactMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *ArtifactMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[artifact.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *ArtifactMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *ArtifactMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, artifact.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *ArtifactMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ArtifactMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ArtifactMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[artifact.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ArtifactMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ArtifactMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, artifact.FieldDescription)
}

// SetCreateTime sets the "create_time" field.
func (m *ArtifactMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ArtifactMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ArtifactMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ArtifactMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ArtifactMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ArtifactMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectUUID sets the "project_uuid" field.
func (m *ArtifactMutation) SetProjectUUID(s string) {
	m.project_uuid = &s
}

// ProjectUUID returns the value of the "project_uuid" field in the mutation.
func (m *ArtifactMutation) ProjectUUID() (r string, exists bool) {
	v := m.project_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectUUID returns the old "project_uuid" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldProjectUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectUUID: %w", err)
	}
	return oldValue.ProjectUUID, nil
}

// ResetProjectUUID resets all changes to the "project_uuid" field.
func (m *ArtifactMutation) ResetProjectUUID() {
	m.project_uuid = nil
}

// SetMimeType sets the "mime_type" field.
func (m *ArtifactMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *ArtifactMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *ArtifactMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetArtifact sets the "artifact" field.
func (m *ArtifactMutation) SetArtifact(b []byte) {
	m.artifact = &b
}

// Artifact returns the value of the "artifact" field in the mutation.
func (m *ArtifactMutation) Artifact() (r []byte, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifact returns the old "artifact" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldArtifact(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifact: %w", err)
	}
	return oldValue.Artifact, nil
}

// ResetArtifact resets all changes to the "artifact" field.
func (m *ArtifactMutation) ResetArtifact() {
	m.artifact = nil
}

// AddCaIconFkIDs adds the "ca_icon_fk" edge to the DeploymentPackage entity by ids.
func (m *ArtifactMutation) AddCaIconFkIDs(ids ...uint64) {
	if m.ca_icon_fk == nil {
		m.ca_icon_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		m.ca_icon_fk[ids[i]] = struct{}{}
	}
}

// ClearCaIconFk clears the "ca_icon_fk" edge to the DeploymentPackage entity.
func (m *ArtifactMutation) ClearCaIconFk() {
	m.clearedca_icon_fk = true
}

// CaIconFkCleared reports if the "ca_icon_fk" edge to the DeploymentPackage entity was cleared.
func (m *ArtifactMutation) CaIconFkCleared() bool {
	return m.clearedca_icon_fk
}

// RemoveCaIconFkIDs removes the "ca_icon_fk" edge to the DeploymentPackage entity by IDs.
func (m *ArtifactMutation) RemoveCaIconFkIDs(ids ...uint64) {
	if m.removedca_icon_fk == nil {
		m.removedca_icon_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.ca_icon_fk, ids[i])
		m.removedca_icon_fk[ids[i]] = struct{}{}
	}
}

// RemovedCaIconFk returns the removed IDs of the "ca_icon_fk" edge to the DeploymentPackage entity.
func (m *ArtifactMutation) RemovedCaIconFkIDs() (ids []uint64) {
	for id := range m.removedca_icon_fk {
		ids = append(ids, id)
	}
	return
}

// CaIconFkIDs returns the "ca_icon_fk" edge IDs in the mutation.
func (m *ArtifactMutation) CaIconFkIDs() (ids []uint64) {
	for id := range m.ca_icon_fk {
		ids = append(ids, id)
	}
	return
}

// ResetCaIconFk resets all changes to the "ca_icon_fk" edge.
func (m *ArtifactMutation) ResetCaIconFk() {
	m.ca_icon_fk = nil
	m.clearedca_icon_fk = false
	m.removedca_icon_fk = nil
}

// AddCaThumbnailFkIDs adds the "ca_thumbnail_fk" edge to the DeploymentPackage entity by ids.
func (m *ArtifactMutation) AddCaThumbnailFkIDs(ids ...uint64) {
	if m.ca_thumbnail_fk == nil {
		m.ca_thumbnail_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		m.ca_thumbnail_fk[ids[i]] = struct{}{}
	}
}

// ClearCaThumbnailFk clears the "ca_thumbnail_fk" edge to the DeploymentPackage entity.
func (m *ArtifactMutation) ClearCaThumbnailFk() {
	m.clearedca_thumbnail_fk = true
}

// CaThumbnailFkCleared reports if the "ca_thumbnail_fk" edge to the DeploymentPackage entity was cleared.
func (m *ArtifactMutation) CaThumbnailFkCleared() bool {
	return m.clearedca_thumbnail_fk
}

// RemoveCaThumbnailFkIDs removes the "ca_thumbnail_fk" edge to the DeploymentPackage entity by IDs.
func (m *ArtifactMutation) RemoveCaThumbnailFkIDs(ids ...uint64) {
	if m.removedca_thumbnail_fk == nil {
		m.removedca_thumbnail_fk = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.ca_thumbnail_fk, ids[i])
		m.removedca_thumbnail_fk[ids[i]] = struct{}{}
	}
}

// RemovedCaThumbnailFk returns the removed IDs of the "ca_thumbnail_fk" edge to the DeploymentPackage entity.
func (m *ArtifactMutation) RemovedCaThumbnailFkIDs() (ids []uint64) {
	for id := range m.removedca_thumbnail_fk {
		ids = append(ids, id)
	}
	return
}

// CaThumbnailFkIDs returns the "ca_thumbnail_fk" edge IDs in the mutation.
func (m *ArtifactMutation) CaThumbnailFkIDs() (ids []uint64) {
	for id := range m.ca_thumbnail_fk {
		ids = append(ids, id)
	}
	return
}

// ResetCaThumbnailFk resets all changes to the "ca_thumbnail_fk" edge.
func (m *ArtifactMutation) ResetCaThumbnailFk() {
	m.ca_thumbnail_fk = nil
	m.clearedca_thumbnail_fk = false
	m.removedca_thumbnail_fk = nil
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artifact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, artifact.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, artifact.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, artifact.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, artifact.FieldDescription)
	}
	if m.create_time != nil {
		fields = append(fields, artifact.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, artifact.FieldUpdateTime)
	}
	if m.project_uuid != nil {
		fields = append(fields, artifact.FieldProjectUUID)
	}
	if m.mime_type != nil {
		fields = append(fields, artifact.FieldMimeType)
	}
	if m.artifact != nil {
		fields = append(fields, artifact.FieldArtifact)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldName:
		return m.Name()
	case artifact.FieldDisplayName:
		return m.DisplayName()
	case artifact.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case artifact.FieldDescription:
		return m.Description()
	case artifact.FieldCreateTime:
		return m.CreateTime()
	case artifact.FieldUpdateTime:
		return m.UpdateTime()
	case artifact.FieldProjectUUID:
		return m.ProjectUUID()
	case artifact.FieldMimeType:
		return m.MimeType()
	case artifact.FieldArtifact:
		return m.Artifact()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldName:
		return m.OldName(ctx)
	case artifact.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case artifact.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case artifact.FieldDescription:
		return m.OldDescription(ctx)
	case artifact.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case artifact.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case artifact.FieldProjectUUID:
		return m.OldProjectUUID(ctx)
	case artifact.FieldMimeType:
		return m.OldMimeType(ctx)
	case artifact.FieldArtifact:
		return m.OldArtifact(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artifact.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case artifact.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case artifact.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case artifact.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case artifact.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case artifact.FieldProjectUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectUUID(v)
		return nil
	case artifact.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case artifact.FieldArtifact:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifact(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artifact.FieldDisplayName) {
		fields = append(fields, artifact.FieldDisplayName)
	}
	if m.FieldCleared(artifact.FieldDisplayNameLc) {
		fields = append(fields, artifact.FieldDisplayNameLc)
	}
	if m.FieldCleared(artifact.FieldDescription) {
		fields = append(fields, artifact.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	switch name {
	case artifact.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case artifact.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case artifact.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldName:
		m.ResetName()
		return nil
	case artifact.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case artifact.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case artifact.FieldDescription:
		m.ResetDescription()
		return nil
	case artifact.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case artifact.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case artifact.FieldProjectUUID:
		m.ResetProjectUUID()
		return nil
	case artifact.FieldMimeType:
		m.ResetMimeType()
		return nil
	case artifact.FieldArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ca_icon_fk != nil {
		edges = append(edges, artifact.EdgeCaIconFk)
	}
	if m.ca_thumbnail_fk != nil {
		edges = append(edges, artifact.EdgeCaThumbnailFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeCaIconFk:
		ids := make([]ent.Value, 0, len(m.ca_icon_fk))
		for id := range m.ca_icon_fk {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeCaThumbnailFk:
		ids := make([]ent.Value, 0, len(m.ca_thumbnail_fk))
		for id := range m.ca_thumbnail_fk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedca_icon_fk != nil {
		edges = append(edges, artifact.EdgeCaIconFk)
	}
	if m.removedca_thumbnail_fk != nil {
		edges = append(edges, artifact.EdgeCaThumbnailFk)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeCaIconFk:
		ids := make([]ent.Value, 0, len(m.removedca_icon_fk))
		for id := range m.removedca_icon_fk {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeCaThumbnailFk:
		ids := make([]ent.Value, 0, len(m.removedca_thumbnail_fk))
		for id := range m.removedca_thumbnail_fk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedca_icon_fk {
		edges = append(edges, artifact.EdgeCaIconFk)
	}
	if m.clearedca_thumbnail_fk {
		edges = append(edges, artifact.EdgeCaThumbnailFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeCaIconFk:
		return m.clearedca_icon_fk
	case artifact.EdgeCaThumbnailFk:
		return m.clearedca_thumbnail_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeCaIconFk:
		m.ResetCaIconFk()
		return nil
	case artifact.EdgeCaThumbnailFk:
		m.ResetCaThumbnailFk()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// ArtifactReferenceMutation represents an operation that mutates the ArtifactReference nodes in the graph.
type ArtifactReferenceMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	purpose                      *string
	clearedFields                map[string]struct{}
	artifact                     *uint64
	clearedartifact              bool
	deployment_package_fk        *uint64
	cleareddeployment_package_fk bool
	done                         bool
	oldValue                     func(context.Context) (*ArtifactReference, error)
	predicates                   []predicate.ArtifactReference
}

var _ ent.Mutation = (*ArtifactReferenceMutation)(nil)

// artifactreferenceOption allows management of the mutation configuration using functional options.
type artifactreferenceOption func(*ArtifactReferenceMutation)

// newArtifactReferenceMutation creates new mutation for the ArtifactReference entity.
func newArtifactReferenceMutation(c config, op Op, opts ...artifactreferenceOption) *ArtifactReferenceMutation {
	m := &ArtifactReferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifactReference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactReferenceID sets the ID field of the mutation.
func withArtifactReferenceID(id uint64) artifactreferenceOption {
	return func(m *ArtifactReferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtifactReference
		)
		m.oldValue = func(ctx context.Context) (*ArtifactReference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtifactReference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifactReference sets the old ArtifactReference of the mutation.
func withArtifactReference(node *ArtifactReference) artifactreferenceOption {
	return func(m *ArtifactReferenceMutation) {
		m.oldValue = func(context.Context) (*ArtifactReference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactReferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactReferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactReferenceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactReferenceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtifactReference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPurpose sets the "purpose" field.
func (m *ArtifactReferenceMutation) SetPurpose(s string) {
	m.purpose = &s
}

// Purpose returns the value of the "purpose" field in the mutation.
func (m *ArtifactReferenceMutation) Purpose() (r string, exists bool) {
	v := m.purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPurpose returns the old "purpose" field's value of the ArtifactReference entity.
// If the ArtifactReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactReferenceMutation) OldPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurpose: %w", err)
	}
	return oldValue.Purpose, nil
}

// ResetPurpose resets all changes to the "purpose" field.
func (m *ArtifactReferenceMutation) ResetPurpose() {
	m.purpose = nil
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by id.
func (m *ArtifactReferenceMutation) SetArtifactID(id uint64) {
	m.artifact = &id
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *ArtifactReferenceMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *ArtifactReferenceMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactID returns the "artifact" edge ID in the mutation.
func (m *ArtifactReferenceMutation) ArtifactID() (id uint64, exists bool) {
	if m.artifact != nil {
		return *m.artifact, true
	}
	return
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *ArtifactReferenceMutation) ArtifactIDs() (ids []uint64) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *ArtifactReferenceMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// SetDeploymentPackageFkID sets the "deployment_package_fk" edge to the DeploymentPackage entity by id.
func (m *ArtifactReferenceMutation) SetDeploymentPackageFkID(id uint64) {
	m.deployment_package_fk = &id
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *ArtifactReferenceMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *ArtifactReferenceMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// DeploymentPackageFkID returns the "deployment_package_fk" edge ID in the mutation.
func (m *ArtifactReferenceMutation) DeploymentPackageFkID() (id uint64, exists bool) {
	if m.deployment_package_fk != nil {
		return *m.deployment_package_fk, true
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentPackageFkID instead. It exists only for internal usage by the builders.
func (m *ArtifactReferenceMutation) DeploymentPackageFkIDs() (ids []uint64) {
	if id := m.deployment_package_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *ArtifactReferenceMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
}

// Where appends a list predicates to the ArtifactReferenceMutation builder.
func (m *ArtifactReferenceMutation) Where(ps ...predicate.ArtifactReference) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactReferenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactReferenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtifactReference, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactReferenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactReferenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtifactReference).
func (m *ArtifactReferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactReferenceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.purpose != nil {
		fields = append(fields, artifactreference.FieldPurpose)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactReferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifactreference.FieldPurpose:
		return m.Purpose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactReferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifactreference.FieldPurpose:
		return m.OldPurpose(ctx)
	}
	return nil, fmt.Errorf("unknown ArtifactReference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactReferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifactreference.FieldPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurpose(v)
		return nil
	}
	return fmt.Errorf("unknown ArtifactReference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactReferenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactReferenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactReferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtifactReference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactReferenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactReferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactReferenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArtifactReference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactReferenceMutation) ResetField(name string) error {
	switch name {
	case artifactreference.FieldPurpose:
		m.ResetPurpose()
		return nil
	}
	return fmt.Errorf("unknown ArtifactReference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactReferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifact != nil {
		edges = append(edges, artifactreference.EdgeArtifact)
	}
	if m.deployment_package_fk != nil {
		edges = append(edges, artifactreference.EdgeDeploymentPackageFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactReferenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifactreference.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case artifactreference.EdgeDeploymentPackageFk:
		if id := m.deployment_package_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactReferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactReferenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactReferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifact {
		edges = append(edges, artifactreference.EdgeArtifact)
	}
	if m.cleareddeployment_package_fk {
		edges = append(edges, artifactreference.EdgeDeploymentPackageFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactReferenceMutation) EdgeCleared(name string) bool {
	switch name {
	case artifactreference.EdgeArtifact:
		return m.clearedartifact
	case artifactreference.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactReferenceMutation) ClearEdge(name string) error {
	switch name {
	case artifactreference.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case artifactreference.EdgeDeploymentPackageFk:
		m.ClearDeploymentPackageFk()
		return nil
	}
	return fmt.Errorf("unknown ArtifactReference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactReferenceMutation) ResetEdge(name string) error {
	switch name {
	case artifactreference.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case artifactreference.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	}
	return fmt.Errorf("unknown ArtifactReference edge %s", name)
}

// CommonMixinMutation represents an operation that mutates the CommonMixin nodes in the graph.
type CommonMixinMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	name            *string
	display_name    *string
	display_name_lc *string
	description     *string
	create_time     *time.Time
	update_time     *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*CommonMixin, error)
	predicates      []predicate.CommonMixin
}

var _ ent.Mutation = (*CommonMixinMutation)(nil)

// commonmixinOption allows management of the mutation configuration using functional options.
type commonmixinOption func(*CommonMixinMutation)

// newCommonMixinMutation creates new mutation for the CommonMixin entity.
func newCommonMixinMutation(c config, op Op, opts ...commonmixinOption) *CommonMixinMutation {
	m := &CommonMixinMutation{
		config:        c,
		op:            op,
		typ:           TypeCommonMixin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommonMixinID sets the ID field of the mutation.
func withCommonMixinID(id uint64) commonmixinOption {
	return func(m *CommonMixinMutation) {
		var (
			err   error
			once  sync.Once
			value *CommonMixin
		)
		m.oldValue = func(ctx context.Context) (*CommonMixin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommonMixin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommonMixin sets the old CommonMixin of the mutation.
func withCommonMixin(node *CommonMixin) commonmixinOption {
	return func(m *CommonMixinMutation) {
		m.oldValue = func(context.Context) (*CommonMixin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommonMixinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommonMixinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommonMixinMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommonMixinMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommonMixin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CommonMixinMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommonMixinMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CommonMixin entity.
// If the CommonMixin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommonMixinMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommonMixinMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *CommonMixinMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CommonMixinMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the CommonMixin entity.
// If the CommonMixin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommonMixinMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CommonMixinMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[commonmixin.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CommonMixinMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[commonmixin.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CommonMixinMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, commonmixin.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *CommonMixinMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *CommonMixinMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the CommonMixin entity.
// If the CommonMixin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommonMixinMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *CommonMixinMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[commonmixin.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *CommonMixinMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[commonmixin.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *CommonMixinMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, commonmixin.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *CommonMixinMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommonMixinMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CommonMixin entity.
// If the CommonMixin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommonMixinMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommonMixinMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[commonmixin.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommonMixinMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[commonmixin.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommonMixinMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, commonmixin.FieldDescription)
}

// SetCreateTime sets the "create_time" field.
func (m *CommonMixinMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CommonMixinMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CommonMixin entity.
// If the CommonMixin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommonMixinMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CommonMixinMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CommonMixinMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CommonMixinMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CommonMixin entity.
// If the CommonMixin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommonMixinMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CommonMixinMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CommonMixinMutation builder.
func (m *CommonMixinMutation) Where(ps ...predicate.CommonMixin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommonMixinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommonMixinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommonMixin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommonMixinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommonMixinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommonMixin).
func (m *CommonMixinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommonMixinMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, commonmixin.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, commonmixin.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, commonmixin.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, commonmixin.FieldDescription)
	}
	if m.create_time != nil {
		fields = append(fields, commonmixin.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, commonmixin.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommonMixinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commonmixin.FieldName:
		return m.Name()
	case commonmixin.FieldDisplayName:
		return m.DisplayName()
	case commonmixin.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case commonmixin.FieldDescription:
		return m.Description()
	case commonmixin.FieldCreateTime:
		return m.CreateTime()
	case commonmixin.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommonMixinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commonmixin.FieldName:
		return m.OldName(ctx)
	case commonmixin.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case commonmixin.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case commonmixin.FieldDescription:
		return m.OldDescription(ctx)
	case commonmixin.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case commonmixin.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CommonMixin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommonMixinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commonmixin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case commonmixin.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case commonmixin.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case commonmixin.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case commonmixin.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case commonmixin.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CommonMixin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommonMixinMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommonMixinMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommonMixinMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CommonMixin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommonMixinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commonmixin.FieldDisplayName) {
		fields = append(fields, commonmixin.FieldDisplayName)
	}
	if m.FieldCleared(commonmixin.FieldDisplayNameLc) {
		fields = append(fields, commonmixin.FieldDisplayNameLc)
	}
	if m.FieldCleared(commonmixin.FieldDescription) {
		fields = append(fields, commonmixin.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommonMixinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommonMixinMutation) ClearField(name string) error {
	switch name {
	case commonmixin.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case commonmixin.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case commonmixin.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CommonMixin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommonMixinMutation) ResetField(name string) error {
	switch name {
	case commonmixin.FieldName:
		m.ResetName()
		return nil
	case commonmixin.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case commonmixin.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case commonmixin.FieldDescription:
		m.ResetDescription()
		return nil
	case commonmixin.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case commonmixin.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CommonMixin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommonMixinMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommonMixinMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommonMixinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommonMixinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommonMixinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommonMixinMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommonMixinMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommonMixin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommonMixinMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommonMixin edge %s", name)
}

// DeploymentPackageMutation represents an operation that mutates the DeploymentPackage nodes in the graph.
type DeploymentPackageMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uint64
	name                            *string
	display_name                    *string
	display_name_lc                 *string
	description                     *string
	create_time                     *time.Time
	update_time                     *time.Time
	project_uuid                    *string
	version                         *string
	is_deployed                     *bool
	is_visible                      *bool
	allows_multiple_deployments     *bool
	kind                            *string
	clearedFields                   map[string]struct{}
	deployment_profiles             map[uint64]struct{}
	removeddeployment_profiles      map[uint64]struct{}
	cleareddeployment_profiles      bool
	applications                    map[uint64]struct{}
	removedapplications             map[uint64]struct{}
	clearedapplications             bool
	icon                            map[uint64]struct{}
	removedicon                     map[uint64]struct{}
	clearedicon                     bool
	thumbnail                       map[uint64]struct{}
	removedthumbnail                map[uint64]struct{}
	clearedthumbnail                bool
	default_profile                 *uint64
	cleareddefault_profile          bool
	application_dependencies        map[uint64]struct{}
	removedapplication_dependencies map[uint64]struct{}
	clearedapplication_dependencies bool
	application_namespaces          map[uint64]struct{}
	removedapplication_namespaces   map[uint64]struct{}
	clearedapplication_namespaces   bool
	namespaces                      map[uint64]struct{}
	removednamespaces               map[uint64]struct{}
	clearednamespaces               bool
	extensions                      map[uint64]struct{}
	removedextensions               map[uint64]struct{}
	clearedextensions               bool
	artifacts                       map[uint64]struct{}
	removedartifacts                map[uint64]struct{}
	clearedartifacts                bool
	done                            bool
	oldValue                        func(context.Context) (*DeploymentPackage, error)
	predicates                      []predicate.DeploymentPackage
}

var _ ent.Mutation = (*DeploymentPackageMutation)(nil)

// deploymentpackageOption allows management of the mutation configuration using functional options.
type deploymentpackageOption func(*DeploymentPackageMutation)

// newDeploymentPackageMutation creates new mutation for the DeploymentPackage entity.
func newDeploymentPackageMutation(c config, op Op, opts ...deploymentpackageOption) *DeploymentPackageMutation {
	m := &DeploymentPackageMutation{
		config:        c,
		op:            op,
		typ:           TypeDeploymentPackage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentPackageID sets the ID field of the mutation.
func withDeploymentPackageID(id uint64) deploymentpackageOption {
	return func(m *DeploymentPackageMutation) {
		var (
			err   error
			once  sync.Once
			value *DeploymentPackage
		)
		m.oldValue = func(ctx context.Context) (*DeploymentPackage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeploymentPackage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeploymentPackage sets the old DeploymentPackage of the mutation.
func withDeploymentPackage(node *DeploymentPackage) deploymentpackageOption {
	return func(m *DeploymentPackageMutation) {
		m.oldValue = func(context.Context) (*DeploymentPackage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentPackageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentPackageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentPackageMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentPackageMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeploymentPackage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DeploymentPackageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentPackageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentPackageMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *DeploymentPackageMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DeploymentPackageMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *DeploymentPackageMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[deploymentpackage.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *DeploymentPackageMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[deploymentpackage.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DeploymentPackageMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, deploymentpackage.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *DeploymentPackageMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *DeploymentPackageMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *DeploymentPackageMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[deploymentpackage.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *DeploymentPackageMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[deploymentpackage.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *DeploymentPackageMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, deploymentpackage.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *DeploymentPackageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeploymentPackageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeploymentPackageMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deploymentpackage.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeploymentPackageMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deploymentpackage.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeploymentPackageMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deploymentpackage.FieldDescription)
}

// SetCreateTime sets the "create_time" field.
func (m *DeploymentPackageMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeploymentPackageMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeploymentPackageMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DeploymentPackageMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeploymentPackageMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeploymentPackageMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectUUID sets the "project_uuid" field.
func (m *DeploymentPackageMutation) SetProjectUUID(s string) {
	m.project_uuid = &s
}

// ProjectUUID returns the value of the "project_uuid" field in the mutation.
func (m *DeploymentPackageMutation) ProjectUUID() (r string, exists bool) {
	v := m.project_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectUUID returns the old "project_uuid" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldProjectUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectUUID: %w", err)
	}
	return oldValue.ProjectUUID, nil
}

// ResetProjectUUID resets all changes to the "project_uuid" field.
func (m *DeploymentPackageMutation) ResetProjectUUID() {
	m.project_uuid = nil
}

// SetVersion sets the "version" field.
func (m *DeploymentPackageMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DeploymentPackageMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *DeploymentPackageMutation) ResetVersion() {
	m.version = nil
}

// SetIsDeployed sets the "is_deployed" field.
func (m *DeploymentPackageMutation) SetIsDeployed(b bool) {
	m.is_deployed = &b
}

// IsDeployed returns the value of the "is_deployed" field in the mutation.
func (m *DeploymentPackageMutation) IsDeployed() (r bool, exists bool) {
	v := m.is_deployed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeployed returns the old "is_deployed" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldIsDeployed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeployed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeployed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeployed: %w", err)
	}
	return oldValue.IsDeployed, nil
}

// ClearIsDeployed clears the value of the "is_deployed" field.
func (m *DeploymentPackageMutation) ClearIsDeployed() {
	m.is_deployed = nil
	m.clearedFields[deploymentpackage.FieldIsDeployed] = struct{}{}
}

// IsDeployedCleared returns if the "is_deployed" field was cleared in this mutation.
func (m *DeploymentPackageMutation) IsDeployedCleared() bool {
	_, ok := m.clearedFields[deploymentpackage.FieldIsDeployed]
	return ok
}

// ResetIsDeployed resets all changes to the "is_deployed" field.
func (m *DeploymentPackageMutation) ResetIsDeployed() {
	m.is_deployed = nil
	delete(m.clearedFields, deploymentpackage.FieldIsDeployed)
}

// SetIsVisible sets the "is_visible" field.
func (m *DeploymentPackageMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *DeploymentPackageMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ClearIsVisible clears the value of the "is_visible" field.
func (m *DeploymentPackageMutation) ClearIsVisible() {
	m.is_visible = nil
	m.clearedFields[deploymentpackage.FieldIsVisible] = struct{}{}
}

// IsVisibleCleared returns if the "is_visible" field was cleared in this mutation.
func (m *DeploymentPackageMutation) IsVisibleCleared() bool {
	_, ok := m.clearedFields[deploymentpackage.FieldIsVisible]
	return ok
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *DeploymentPackageMutation) ResetIsVisible() {
	m.is_visible = nil
	delete(m.clearedFields, deploymentpackage.FieldIsVisible)
}

// SetAllowsMultipleDeployments sets the "allows_multiple_deployments" field.
func (m *DeploymentPackageMutation) SetAllowsMultipleDeployments(b bool) {
	m.allows_multiple_deployments = &b
}

// AllowsMultipleDeployments returns the value of the "allows_multiple_deployments" field in the mutation.
func (m *DeploymentPackageMutation) AllowsMultipleDeployments() (r bool, exists bool) {
	v := m.allows_multiple_deployments
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowsMultipleDeployments returns the old "allows_multiple_deployments" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldAllowsMultipleDeployments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowsMultipleDeployments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowsMultipleDeployments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowsMultipleDeployments: %w", err)
	}
	return oldValue.AllowsMultipleDeployments, nil
}

// ClearAllowsMultipleDeployments clears the value of the "allows_multiple_deployments" field.
func (m *DeploymentPackageMutation) ClearAllowsMultipleDeployments() {
	m.allows_multiple_deployments = nil
	m.clearedFields[deploymentpackage.FieldAllowsMultipleDeployments] = struct{}{}
}

// AllowsMultipleDeploymentsCleared returns if the "allows_multiple_deployments" field was cleared in this mutation.
func (m *DeploymentPackageMutation) AllowsMultipleDeploymentsCleared() bool {
	_, ok := m.clearedFields[deploymentpackage.FieldAllowsMultipleDeployments]
	return ok
}

// ResetAllowsMultipleDeployments resets all changes to the "allows_multiple_deployments" field.
func (m *DeploymentPackageMutation) ResetAllowsMultipleDeployments() {
	m.allows_multiple_deployments = nil
	delete(m.clearedFields, deploymentpackage.FieldAllowsMultipleDeployments)
}

// SetKind sets the "kind" field.
func (m *DeploymentPackageMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *DeploymentPackageMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the DeploymentPackage entity.
// If the DeploymentPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentPackageMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *DeploymentPackageMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[deploymentpackage.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *DeploymentPackageMutation) KindCleared() bool {
	_, ok := m.clearedFields[deploymentpackage.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *DeploymentPackageMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, deploymentpackage.FieldKind)
}

// AddDeploymentProfileIDs adds the "deployment_profiles" edge to the DeploymentProfile entity by ids.
func (m *DeploymentPackageMutation) AddDeploymentProfileIDs(ids ...uint64) {
	if m.deployment_profiles == nil {
		m.deployment_profiles = make(map[uint64]struct{})
	}
	for i := range ids {
		m.deployment_profiles[ids[i]] = struct{}{}
	}
}

// ClearDeploymentProfiles clears the "deployment_profiles" edge to the DeploymentProfile entity.
func (m *DeploymentPackageMutation) ClearDeploymentProfiles() {
	m.cleareddeployment_profiles = true
}

// DeploymentProfilesCleared reports if the "deployment_profiles" edge to the DeploymentProfile entity was cleared.
func (m *DeploymentPackageMutation) DeploymentProfilesCleared() bool {
	return m.cleareddeployment_profiles
}

// RemoveDeploymentProfileIDs removes the "deployment_profiles" edge to the DeploymentProfile entity by IDs.
func (m *DeploymentPackageMutation) RemoveDeploymentProfileIDs(ids ...uint64) {
	if m.removeddeployment_profiles == nil {
		m.removeddeployment_profiles = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.deployment_profiles, ids[i])
		m.removeddeployment_profiles[ids[i]] = struct{}{}
	}
}

// RemovedDeploymentProfiles returns the removed IDs of the "deployment_profiles" edge to the DeploymentProfile entity.
func (m *DeploymentPackageMutation) RemovedDeploymentProfilesIDs() (ids []uint64) {
	for id := range m.removeddeployment_profiles {
		ids = append(ids, id)
	}
	return
}

// DeploymentProfilesIDs returns the "deployment_profiles" edge IDs in the mutation.
func (m *DeploymentPackageMutation) DeploymentProfilesIDs() (ids []uint64) {
	for id := range m.deployment_profiles {
		ids = append(ids, id)
	}
	return
}

// ResetDeploymentProfiles resets all changes to the "deployment_profiles" edge.
func (m *DeploymentPackageMutation) ResetDeploymentProfiles() {
	m.deployment_profiles = nil
	m.cleareddeployment_profiles = false
	m.removeddeployment_profiles = nil
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *DeploymentPackageMutation) AddApplicationIDs(ids ...uint64) {
	if m.applications == nil {
		m.applications = make(map[uint64]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *DeploymentPackageMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *DeploymentPackageMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *DeploymentPackageMutation) RemoveApplicationIDs(ids ...uint64) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *DeploymentPackageMutation) RemovedApplicationsIDs() (ids []uint64) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *DeploymentPackageMutation) ApplicationsIDs() (ids []uint64) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *DeploymentPackageMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddIconIDs adds the "icon" edge to the Artifact entity by ids.
func (m *DeploymentPackageMutation) AddIconIDs(ids ...uint64) {
	if m.icon == nil {
		m.icon = make(map[uint64]struct{})
	}
	for i := range ids {
		m.icon[ids[i]] = struct{}{}
	}
}

// ClearIcon clears the "icon" edge to the Artifact entity.
func (m *DeploymentPackageMutation) ClearIcon() {
	m.clearedicon = true
}

// IconCleared reports if the "icon" edge to the Artifact entity was cleared.
func (m *DeploymentPackageMutation) IconCleared() bool {
	return m.clearedicon
}

// RemoveIconIDs removes the "icon" edge to the Artifact entity by IDs.
func (m *DeploymentPackageMutation) RemoveIconIDs(ids ...uint64) {
	if m.removedicon == nil {
		m.removedicon = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.icon, ids[i])
		m.removedicon[ids[i]] = struct{}{}
	}
}

// RemovedIcon returns the removed IDs of the "icon" edge to the Artifact entity.
func (m *DeploymentPackageMutation) RemovedIconIDs() (ids []uint64) {
	for id := range m.removedicon {
		ids = append(ids, id)
	}
	return
}

// IconIDs returns the "icon" edge IDs in the mutation.
func (m *DeploymentPackageMutation) IconIDs() (ids []uint64) {
	for id := range m.icon {
		ids = append(ids, id)
	}
	return
}

// ResetIcon resets all changes to the "icon" edge.
func (m *DeploymentPackageMutation) ResetIcon() {
	m.icon = nil
	m.clearedicon = false
	m.removedicon = nil
}

// AddThumbnailIDs adds the "thumbnail" edge to the Artifact entity by ids.
func (m *DeploymentPackageMutation) AddThumbnailIDs(ids ...uint64) {
	if m.thumbnail == nil {
		m.thumbnail = make(map[uint64]struct{})
	}
	for i := range ids {
		m.thumbnail[ids[i]] = struct{}{}
	}
}

// ClearThumbnail clears the "thumbnail" edge to the Artifact entity.
func (m *DeploymentPackageMutation) ClearThumbnail() {
	m.clearedthumbnail = true
}

// ThumbnailCleared reports if the "thumbnail" edge to the Artifact entity was cleared.
func (m *DeploymentPackageMutation) ThumbnailCleared() bool {
	return m.clearedthumbnail
}

// RemoveThumbnailIDs removes the "thumbnail" edge to the Artifact entity by IDs.
func (m *DeploymentPackageMutation) RemoveThumbnailIDs(ids ...uint64) {
	if m.removedthumbnail == nil {
		m.removedthumbnail = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.thumbnail, ids[i])
		m.removedthumbnail[ids[i]] = struct{}{}
	}
}

// RemovedThumbnail returns the removed IDs of the "thumbnail" edge to the Artifact entity.
func (m *DeploymentPackageMutation) RemovedThumbnailIDs() (ids []uint64) {
	for id := range m.removedthumbnail {
		ids = append(ids, id)
	}
	return
}

// ThumbnailIDs returns the "thumbnail" edge IDs in the mutation.
func (m *DeploymentPackageMutation) ThumbnailIDs() (ids []uint64) {
	for id := range m.thumbnail {
		ids = append(ids, id)
	}
	return
}

// ResetThumbnail resets all changes to the "thumbnail" edge.
func (m *DeploymentPackageMutation) ResetThumbnail() {
	m.thumbnail = nil
	m.clearedthumbnail = false
	m.removedthumbnail = nil
}

// SetDefaultProfileID sets the "default_profile" edge to the DeploymentProfile entity by id.
func (m *DeploymentPackageMutation) SetDefaultProfileID(id uint64) {
	m.default_profile = &id
}

// ClearDefaultProfile clears the "default_profile" edge to the DeploymentProfile entity.
func (m *DeploymentPackageMutation) ClearDefaultProfile() {
	m.cleareddefault_profile = true
}

// DefaultProfileCleared reports if the "default_profile" edge to the DeploymentProfile entity was cleared.
func (m *DeploymentPackageMutation) DefaultProfileCleared() bool {
	return m.cleareddefault_profile
}

// DefaultProfileID returns the "default_profile" edge ID in the mutation.
func (m *DeploymentPackageMutation) DefaultProfileID() (id uint64, exists bool) {
	if m.default_profile != nil {
		return *m.default_profile, true
	}
	return
}

// DefaultProfileIDs returns the "default_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultProfileID instead. It exists only for internal usage by the builders.
func (m *DeploymentPackageMutation) DefaultProfileIDs() (ids []uint64) {
	if id := m.default_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultProfile resets all changes to the "default_profile" edge.
func (m *DeploymentPackageMutation) ResetDefaultProfile() {
	m.default_profile = nil
	m.cleareddefault_profile = false
}

// AddApplicationDependencyIDs adds the "application_dependencies" edge to the ApplicationDependency entity by ids.
func (m *DeploymentPackageMutation) AddApplicationDependencyIDs(ids ...uint64) {
	if m.application_dependencies == nil {
		m.application_dependencies = make(map[uint64]struct{})
	}
	for i := range ids {
		m.application_dependencies[ids[i]] = struct{}{}
	}
}

// ClearApplicationDependencies clears the "application_dependencies" edge to the ApplicationDependency entity.
func (m *DeploymentPackageMutation) ClearApplicationDependencies() {
	m.clearedapplication_dependencies = true
}

// ApplicationDependenciesCleared reports if the "application_dependencies" edge to the ApplicationDependency entity was cleared.
func (m *DeploymentPackageMutation) ApplicationDependenciesCleared() bool {
	return m.clearedapplication_dependencies
}

// RemoveApplicationDependencyIDs removes the "application_dependencies" edge to the ApplicationDependency entity by IDs.
func (m *DeploymentPackageMutation) RemoveApplicationDependencyIDs(ids ...uint64) {
	if m.removedapplication_dependencies == nil {
		m.removedapplication_dependencies = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.application_dependencies, ids[i])
		m.removedapplication_dependencies[ids[i]] = struct{}{}
	}
}

// RemovedApplicationDependencies returns the removed IDs of the "application_dependencies" edge to the ApplicationDependency entity.
func (m *DeploymentPackageMutation) RemovedApplicationDependenciesIDs() (ids []uint64) {
	for id := range m.removedapplication_dependencies {
		ids = append(ids, id)
	}
	return
}

// ApplicationDependenciesIDs returns the "application_dependencies" edge IDs in the mutation.
func (m *DeploymentPackageMutation) ApplicationDependenciesIDs() (ids []uint64) {
	for id := range m.application_dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetApplicationDependencies resets all changes to the "application_dependencies" edge.
func (m *DeploymentPackageMutation) ResetApplicationDependencies() {
	m.application_dependencies = nil
	m.clearedapplication_dependencies = false
	m.removedapplication_dependencies = nil
}

// AddApplicationNamespaceIDs adds the "application_namespaces" edge to the ApplicationNamespace entity by ids.
func (m *DeploymentPackageMutation) AddApplicationNamespaceIDs(ids ...uint64) {
	if m.application_namespaces == nil {
		m.application_namespaces = make(map[uint64]struct{})
	}
	for i := range ids {
		m.application_namespaces[ids[i]] = struct{}{}
	}
}

// ClearApplicationNamespaces clears the "application_namespaces" edge to the ApplicationNamespace entity.
func (m *DeploymentPackageMutation) ClearApplicationNamespaces() {
	m.clearedapplication_namespaces = true
}

// ApplicationNamespacesCleared reports if the "application_namespaces" edge to the ApplicationNamespace entity was cleared.
func (m *DeploymentPackageMutation) ApplicationNamespacesCleared() bool {
	return m.clearedapplication_namespaces
}

// RemoveApplicationNamespaceIDs removes the "application_namespaces" edge to the ApplicationNamespace entity by IDs.
func (m *DeploymentPackageMutation) RemoveApplicationNamespaceIDs(ids ...uint64) {
	if m.removedapplication_namespaces == nil {
		m.removedapplication_namespaces = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.application_namespaces, ids[i])
		m.removedapplication_namespaces[ids[i]] = struct{}{}
	}
}

// RemovedApplicationNamespaces returns the removed IDs of the "application_namespaces" edge to the ApplicationNamespace entity.
func (m *DeploymentPackageMutation) RemovedApplicationNamespacesIDs() (ids []uint64) {
	for id := range m.removedapplication_namespaces {
		ids = append(ids, id)
	}
	return
}

// ApplicationNamespacesIDs returns the "application_namespaces" edge IDs in the mutation.
func (m *DeploymentPackageMutation) ApplicationNamespacesIDs() (ids []uint64) {
	for id := range m.application_namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetApplicationNamespaces resets all changes to the "application_namespaces" edge.
func (m *DeploymentPackageMutation) ResetApplicationNamespaces() {
	m.application_namespaces = nil
	m.clearedapplication_namespaces = false
	m.removedapplication_namespaces = nil
}

// AddNamespaceIDs adds the "namespaces" edge to the Namespace entity by ids.
func (m *DeploymentPackageMutation) AddNamespaceIDs(ids ...uint64) {
	if m.namespaces == nil {
		m.namespaces = make(map[uint64]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the "namespaces" edge to the Namespace entity.
func (m *DeploymentPackageMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared reports if the "namespaces" edge to the Namespace entity was cleared.
func (m *DeploymentPackageMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the "namespaces" edge to the Namespace entity by IDs.
func (m *DeploymentPackageMutation) RemoveNamespaceIDs(ids ...uint64) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.namespaces, ids[i])
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed IDs of the "namespaces" edge to the Namespace entity.
func (m *DeploymentPackageMutation) RemovedNamespacesIDs() (ids []uint64) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the "namespaces" edge IDs in the mutation.
func (m *DeploymentPackageMutation) NamespacesIDs() (ids []uint64) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces resets all changes to the "namespaces" edge.
func (m *DeploymentPackageMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// AddExtensionIDs adds the "extensions" edge to the Extension entity by ids.
func (m *DeploymentPackageMutation) AddExtensionIDs(ids ...uint64) {
	if m.extensions == nil {
		m.extensions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.extensions[ids[i]] = struct{}{}
	}
}

// ClearExtensions clears the "extensions" edge to the Extension entity.
func (m *DeploymentPackageMutation) ClearExtensions() {
	m.clearedextensions = true
}

// ExtensionsCleared reports if the "extensions" edge to the Extension entity was cleared.
func (m *DeploymentPackageMutation) ExtensionsCleared() bool {
	return m.clearedextensions
}

// RemoveExtensionIDs removes the "extensions" edge to the Extension entity by IDs.
func (m *DeploymentPackageMutation) RemoveExtensionIDs(ids ...uint64) {
	if m.removedextensions == nil {
		m.removedextensions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.extensions, ids[i])
		m.removedextensions[ids[i]] = struct{}{}
	}
}

// RemovedExtensions returns the removed IDs of the "extensions" edge to the Extension entity.
func (m *DeploymentPackageMutation) RemovedExtensionsIDs() (ids []uint64) {
	for id := range m.removedextensions {
		ids = append(ids, id)
	}
	return
}

// ExtensionsIDs returns the "extensions" edge IDs in the mutation.
func (m *DeploymentPackageMutation) ExtensionsIDs() (ids []uint64) {
	for id := range m.extensions {
		ids = append(ids, id)
	}
	return
}

// ResetExtensions resets all changes to the "extensions" edge.
func (m *DeploymentPackageMutation) ResetExtensions() {
	m.extensions = nil
	m.clearedextensions = false
	m.removedextensions = nil
}

// AddArtifactIDs adds the "artifacts" edge to the ArtifactReference entity by ids.
func (m *DeploymentPackageMutation) AddArtifactIDs(ids ...uint64) {
	if m.artifacts == nil {
		m.artifacts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the ArtifactReference entity.
func (m *DeploymentPackageMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the ArtifactReference entity was cleared.
func (m *DeploymentPackageMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the ArtifactReference entity by IDs.
func (m *DeploymentPackageMutation) RemoveArtifactIDs(ids ...uint64) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the ArtifactReference entity.
func (m *DeploymentPackageMutation) RemovedArtifactsIDs() (ids []uint64) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *DeploymentPackageMutation) ArtifactsIDs() (ids []uint64) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *DeploymentPackageMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the DeploymentPackageMutation builder.
func (m *DeploymentPackageMutation) Where(ps ...predicate.DeploymentPackage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentPackageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentPackageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeploymentPackage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentPackageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentPackageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeploymentPackage).
func (m *DeploymentPackageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentPackageMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, deploymentpackage.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, deploymentpackage.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, deploymentpackage.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, deploymentpackage.FieldDescription)
	}
	if m.create_time != nil {
		fields = append(fields, deploymentpackage.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, deploymentpackage.FieldUpdateTime)
	}
	if m.project_uuid != nil {
		fields = append(fields, deploymentpackage.FieldProjectUUID)
	}
	if m.version != nil {
		fields = append(fields, deploymentpackage.FieldVersion)
	}
	if m.is_deployed != nil {
		fields = append(fields, deploymentpackage.FieldIsDeployed)
	}
	if m.is_visible != nil {
		fields = append(fields, deploymentpackage.FieldIsVisible)
	}
	if m.allows_multiple_deployments != nil {
		fields = append(fields, deploymentpackage.FieldAllowsMultipleDeployments)
	}
	if m.kind != nil {
		fields = append(fields, deploymentpackage.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentPackageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deploymentpackage.FieldName:
		return m.Name()
	case deploymentpackage.FieldDisplayName:
		return m.DisplayName()
	case deploymentpackage.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case deploymentpackage.FieldDescription:
		return m.Description()
	case deploymentpackage.FieldCreateTime:
		return m.CreateTime()
	case deploymentpackage.FieldUpdateTime:
		return m.UpdateTime()
	case deploymentpackage.FieldProjectUUID:
		return m.ProjectUUID()
	case deploymentpackage.FieldVersion:
		return m.Version()
	case deploymentpackage.FieldIsDeployed:
		return m.IsDeployed()
	case deploymentpackage.FieldIsVisible:
		return m.IsVisible()
	case deploymentpackage.FieldAllowsMultipleDeployments:
		return m.AllowsMultipleDeployments()
	case deploymentpackage.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentPackageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deploymentpackage.FieldName:
		return m.OldName(ctx)
	case deploymentpackage.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case deploymentpackage.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case deploymentpackage.FieldDescription:
		return m.OldDescription(ctx)
	case deploymentpackage.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case deploymentpackage.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case deploymentpackage.FieldProjectUUID:
		return m.OldProjectUUID(ctx)
	case deploymentpackage.FieldVersion:
		return m.OldVersion(ctx)
	case deploymentpackage.FieldIsDeployed:
		return m.OldIsDeployed(ctx)
	case deploymentpackage.FieldIsVisible:
		return m.OldIsVisible(ctx)
	case deploymentpackage.FieldAllowsMultipleDeployments:
		return m.OldAllowsMultipleDeployments(ctx)
	case deploymentpackage.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown DeploymentPackage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentPackageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deploymentpackage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deploymentpackage.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case deploymentpackage.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case deploymentpackage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case deploymentpackage.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case deploymentpackage.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case deploymentpackage.FieldProjectUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectUUID(v)
		return nil
	case deploymentpackage.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case deploymentpackage.FieldIsDeployed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeployed(v)
		return nil
	case deploymentpackage.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	case deploymentpackage.FieldAllowsMultipleDeployments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowsMultipleDeployments(v)
		return nil
	case deploymentpackage.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentPackage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentPackageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentPackageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentPackageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeploymentPackage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentPackageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deploymentpackage.FieldDisplayName) {
		fields = append(fields, deploymentpackage.FieldDisplayName)
	}
	if m.FieldCleared(deploymentpackage.FieldDisplayNameLc) {
		fields = append(fields, deploymentpackage.FieldDisplayNameLc)
	}
	if m.FieldCleared(deploymentpackage.FieldDescription) {
		fields = append(fields, deploymentpackage.FieldDescription)
	}
	if m.FieldCleared(deploymentpackage.FieldIsDeployed) {
		fields = append(fields, deploymentpackage.FieldIsDeployed)
	}
	if m.FieldCleared(deploymentpackage.FieldIsVisible) {
		fields = append(fields, deploymentpackage.FieldIsVisible)
	}
	if m.FieldCleared(deploymentpackage.FieldAllowsMultipleDeployments) {
		fields = append(fields, deploymentpackage.FieldAllowsMultipleDeployments)
	}
	if m.FieldCleared(deploymentpackage.FieldKind) {
		fields = append(fields, deploymentpackage.FieldKind)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentPackageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentPackageMutation) ClearField(name string) error {
	switch name {
	case deploymentpackage.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case deploymentpackage.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case deploymentpackage.FieldDescription:
		m.ClearDescription()
		return nil
	case deploymentpackage.FieldIsDeployed:
		m.ClearIsDeployed()
		return nil
	case deploymentpackage.FieldIsVisible:
		m.ClearIsVisible()
		return nil
	case deploymentpackage.FieldAllowsMultipleDeployments:
		m.ClearAllowsMultipleDeployments()
		return nil
	case deploymentpackage.FieldKind:
		m.ClearKind()
		return nil
	}
	return fmt.Errorf("unknown DeploymentPackage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentPackageMutation) ResetField(name string) error {
	switch name {
	case deploymentpackage.FieldName:
		m.ResetName()
		return nil
	case deploymentpackage.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case deploymentpackage.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case deploymentpackage.FieldDescription:
		m.ResetDescription()
		return nil
	case deploymentpackage.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case deploymentpackage.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case deploymentpackage.FieldProjectUUID:
		m.ResetProjectUUID()
		return nil
	case deploymentpackage.FieldVersion:
		m.ResetVersion()
		return nil
	case deploymentpackage.FieldIsDeployed:
		m.ResetIsDeployed()
		return nil
	case deploymentpackage.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	case deploymentpackage.FieldAllowsMultipleDeployments:
		m.ResetAllowsMultipleDeployments()
		return nil
	case deploymentpackage.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown DeploymentPackage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentPackageMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.deployment_profiles != nil {
		edges = append(edges, deploymentpackage.EdgeDeploymentProfiles)
	}
	if m.applications != nil {
		edges = append(edges, deploymentpackage.EdgeApplications)
	}
	if m.icon != nil {
		edges = append(edges, deploymentpackage.EdgeIcon)
	}
	if m.thumbnail != nil {
		edges = append(edges, deploymentpackage.EdgeThumbnail)
	}
	if m.default_profile != nil {
		edges = append(edges, deploymentpackage.EdgeDefaultProfile)
	}
	if m.application_dependencies != nil {
		edges = append(edges, deploymentpackage.EdgeApplicationDependencies)
	}
	if m.application_namespaces != nil {
		edges = append(edges, deploymentpackage.EdgeApplicationNamespaces)
	}
	if m.namespaces != nil {
		edges = append(edges, deploymentpackage.EdgeNamespaces)
	}
	if m.extensions != nil {
		edges = append(edges, deploymentpackage.EdgeExtensions)
	}
	if m.artifacts != nil {
		edges = append(edges, deploymentpackage.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentPackageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deploymentpackage.EdgeDeploymentProfiles:
		ids := make([]ent.Value, 0, len(m.deployment_profiles))
		for id := range m.deployment_profiles {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeIcon:
		ids := make([]ent.Value, 0, len(m.icon))
		for id := range m.icon {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeThumbnail:
		ids := make([]ent.Value, 0, len(m.thumbnail))
		for id := range m.thumbnail {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeDefaultProfile:
		if id := m.default_profile; id != nil {
			return []ent.Value{*id}
		}
	case deploymentpackage.EdgeApplicationDependencies:
		ids := make([]ent.Value, 0, len(m.application_dependencies))
		for id := range m.application_dependencies {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeApplicationNamespaces:
		ids := make([]ent.Value, 0, len(m.application_namespaces))
		for id := range m.application_namespaces {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeExtensions:
		ids := make([]ent.Value, 0, len(m.extensions))
		for id := range m.extensions {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentPackageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removeddeployment_profiles != nil {
		edges = append(edges, deploymentpackage.EdgeDeploymentProfiles)
	}
	if m.removedapplications != nil {
		edges = append(edges, deploymentpackage.EdgeApplications)
	}
	if m.removedicon != nil {
		edges = append(edges, deploymentpackage.EdgeIcon)
	}
	if m.removedthumbnail != nil {
		edges = append(edges, deploymentpackage.EdgeThumbnail)
	}
	if m.removedapplication_dependencies != nil {
		edges = append(edges, deploymentpackage.EdgeApplicationDependencies)
	}
	if m.removedapplication_namespaces != nil {
		edges = append(edges, deploymentpackage.EdgeApplicationNamespaces)
	}
	if m.removednamespaces != nil {
		edges = append(edges, deploymentpackage.EdgeNamespaces)
	}
	if m.removedextensions != nil {
		edges = append(edges, deploymentpackage.EdgeExtensions)
	}
	if m.removedartifacts != nil {
		edges = append(edges, deploymentpackage.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentPackageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deploymentpackage.EdgeDeploymentProfiles:
		ids := make([]ent.Value, 0, len(m.removeddeployment_profiles))
		for id := range m.removeddeployment_profiles {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeIcon:
		ids := make([]ent.Value, 0, len(m.removedicon))
		for id := range m.removedicon {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeThumbnail:
		ids := make([]ent.Value, 0, len(m.removedthumbnail))
		for id := range m.removedthumbnail {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeApplicationDependencies:
		ids := make([]ent.Value, 0, len(m.removedapplication_dependencies))
		for id := range m.removedapplication_dependencies {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeApplicationNamespaces:
		ids := make([]ent.Value, 0, len(m.removedapplication_namespaces))
		for id := range m.removedapplication_namespaces {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeExtensions:
		ids := make([]ent.Value, 0, len(m.removedextensions))
		for id := range m.removedextensions {
			ids = append(ids, id)
		}
		return ids
	case deploymentpackage.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentPackageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleareddeployment_profiles {
		edges = append(edges, deploymentpackage.EdgeDeploymentProfiles)
	}
	if m.clearedapplications {
		edges = append(edges, deploymentpackage.EdgeApplications)
	}
	if m.clearedicon {
		edges = append(edges, deploymentpackage.EdgeIcon)
	}
	if m.clearedthumbnail {
		edges = append(edges, deploymentpackage.EdgeThumbnail)
	}
	if m.cleareddefault_profile {
		edges = append(edges, deploymentpackage.EdgeDefaultProfile)
	}
	if m.clearedapplication_dependencies {
		edges = append(edges, deploymentpackage.EdgeApplicationDependencies)
	}
	if m.clearedapplication_namespaces {
		edges = append(edges, deploymentpackage.EdgeApplicationNamespaces)
	}
	if m.clearednamespaces {
		edges = append(edges, deploymentpackage.EdgeNamespaces)
	}
	if m.clearedextensions {
		edges = append(edges, deploymentpackage.EdgeExtensions)
	}
	if m.clearedartifacts {
		edges = append(edges, deploymentpackage.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentPackageMutation) EdgeCleared(name string) bool {
	switch name {
	case deploymentpackage.EdgeDeploymentProfiles:
		return m.cleareddeployment_profiles
	case deploymentpackage.EdgeApplications:
		return m.clearedapplications
	case deploymentpackage.EdgeIcon:
		return m.clearedicon
	case deploymentpackage.EdgeThumbnail:
		return m.clearedthumbnail
	case deploymentpackage.EdgeDefaultProfile:
		return m.cleareddefault_profile
	case deploymentpackage.EdgeApplicationDependencies:
		return m.clearedapplication_dependencies
	case deploymentpackage.EdgeApplicationNamespaces:
		return m.clearedapplication_namespaces
	case deploymentpackage.EdgeNamespaces:
		return m.clearednamespaces
	case deploymentpackage.EdgeExtensions:
		return m.clearedextensions
	case deploymentpackage.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentPackageMutation) ClearEdge(name string) error {
	switch name {
	case deploymentpackage.EdgeDefaultProfile:
		m.ClearDefaultProfile()
		return nil
	}
	return fmt.Errorf("unknown DeploymentPackage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentPackageMutation) ResetEdge(name string) error {
	switch name {
	case deploymentpackage.EdgeDeploymentProfiles:
		m.ResetDeploymentProfiles()
		return nil
	case deploymentpackage.EdgeApplications:
		m.ResetApplications()
		return nil
	case deploymentpackage.EdgeIcon:
		m.ResetIcon()
		return nil
	case deploymentpackage.EdgeThumbnail:
		m.ResetThumbnail()
		return nil
	case deploymentpackage.EdgeDefaultProfile:
		m.ResetDefaultProfile()
		return nil
	case deploymentpackage.EdgeApplicationDependencies:
		m.ResetApplicationDependencies()
		return nil
	case deploymentpackage.EdgeApplicationNamespaces:
		m.ResetApplicationNamespaces()
		return nil
	case deploymentpackage.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	case deploymentpackage.EdgeExtensions:
		m.ResetExtensions()
		return nil
	case deploymentpackage.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown DeploymentPackage edge %s", name)
}

// DeploymentProfileMutation represents an operation that mutates the DeploymentProfile nodes in the graph.
type DeploymentProfileMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	name                         *string
	display_name                 *string
	display_name_lc              *string
	description                  *string
	create_time                  *time.Time
	update_time                  *time.Time
	clearedFields                map[string]struct{}
	profiles                     map[uint64]struct{}
	removedprofiles              map[uint64]struct{}
	clearedprofiles              bool
	deployment_package_fk        *uint64
	cleareddeployment_package_fk bool
	done                         bool
	oldValue                     func(context.Context) (*DeploymentProfile, error)
	predicates                   []predicate.DeploymentProfile
}

var _ ent.Mutation = (*DeploymentProfileMutation)(nil)

// deploymentprofileOption allows management of the mutation configuration using functional options.
type deploymentprofileOption func(*DeploymentProfileMutation)

// newDeploymentProfileMutation creates new mutation for the DeploymentProfile entity.
func newDeploymentProfileMutation(c config, op Op, opts ...deploymentprofileOption) *DeploymentProfileMutation {
	m := &DeploymentProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeDeploymentProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentProfileID sets the ID field of the mutation.
func withDeploymentProfileID(id uint64) deploymentprofileOption {
	return func(m *DeploymentProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *DeploymentProfile
		)
		m.oldValue = func(ctx context.Context) (*DeploymentProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeploymentProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeploymentProfile sets the old DeploymentProfile of the mutation.
func withDeploymentProfile(node *DeploymentProfile) deploymentprofileOption {
	return func(m *DeploymentProfileMutation) {
		m.oldValue = func(context.Context) (*DeploymentProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentProfileMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentProfileMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeploymentProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DeploymentProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeploymentProfile entity.
// If the DeploymentProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentProfileMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *DeploymentProfileMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DeploymentProfileMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the DeploymentProfile entity.
// If the DeploymentProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentProfileMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *DeploymentProfileMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[deploymentprofile.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *DeploymentProfileMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[deploymentprofile.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DeploymentProfileMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, deploymentprofile.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *DeploymentProfileMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *DeploymentProfileMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the DeploymentProfile entity.
// If the DeploymentProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentProfileMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *DeploymentProfileMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[deploymentprofile.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *DeploymentProfileMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[deploymentprofile.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *DeploymentProfileMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, deploymentprofile.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *DeploymentProfileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeploymentProfileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeploymentProfile entity.
// If the DeploymentProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentProfileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeploymentProfileMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deploymentprofile.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeploymentProfileMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deploymentprofile.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeploymentProfileMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deploymentprofile.FieldDescription)
}

// SetCreateTime sets the "create_time" field.
func (m *DeploymentProfileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeploymentProfileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DeploymentProfile entity.
// If the DeploymentProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentProfileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeploymentProfileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DeploymentProfileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeploymentProfileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DeploymentProfile entity.
// If the DeploymentProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentProfileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeploymentProfileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddProfileIDs adds the "profiles" edge to the Profile entity by ids.
func (m *DeploymentProfileMutation) AddProfileIDs(ids ...uint64) {
	if m.profiles == nil {
		m.profiles = make(map[uint64]struct{})
	}
	for i := range ids {
		m.profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "profiles" edge to the Profile entity.
func (m *DeploymentProfileMutation) ClearProfiles() {
	m.clearedprofiles = true
}

// ProfilesCleared reports if the "profiles" edge to the Profile entity was cleared.
func (m *DeploymentProfileMutation) ProfilesCleared() bool {
	return m.clearedprofiles
}

// RemoveProfileIDs removes the "profiles" edge to the Profile entity by IDs.
func (m *DeploymentProfileMutation) RemoveProfileIDs(ids ...uint64) {
	if m.removedprofiles == nil {
		m.removedprofiles = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.profiles, ids[i])
		m.removedprofiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "profiles" edge to the Profile entity.
func (m *DeploymentProfileMutation) RemovedProfilesIDs() (ids []uint64) {
	for id := range m.removedprofiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "profiles" edge IDs in the mutation.
func (m *DeploymentProfileMutation) ProfilesIDs() (ids []uint64) {
	for id := range m.profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "profiles" edge.
func (m *DeploymentProfileMutation) ResetProfiles() {
	m.profiles = nil
	m.clearedprofiles = false
	m.removedprofiles = nil
}

// SetDeploymentPackageFkID sets the "deployment_package_fk" edge to the DeploymentPackage entity by id.
func (m *DeploymentProfileMutation) SetDeploymentPackageFkID(id uint64) {
	m.deployment_package_fk = &id
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *DeploymentProfileMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *DeploymentProfileMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// DeploymentPackageFkID returns the "deployment_package_fk" edge ID in the mutation.
func (m *DeploymentProfileMutation) DeploymentPackageFkID() (id uint64, exists bool) {
	if m.deployment_package_fk != nil {
		return *m.deployment_package_fk, true
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentPackageFkID instead. It exists only for internal usage by the builders.
func (m *DeploymentProfileMutation) DeploymentPackageFkIDs() (ids []uint64) {
	if id := m.deployment_package_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *DeploymentProfileMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
}

// Where appends a list predicates to the DeploymentProfileMutation builder.
func (m *DeploymentProfileMutation) Where(ps ...predicate.DeploymentProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeploymentProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeploymentProfile).
func (m *DeploymentProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentProfileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, deploymentprofile.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, deploymentprofile.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, deploymentprofile.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, deploymentprofile.FieldDescription)
	}
	if m.create_time != nil {
		fields = append(fields, deploymentprofile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, deploymentprofile.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deploymentprofile.FieldName:
		return m.Name()
	case deploymentprofile.FieldDisplayName:
		return m.DisplayName()
	case deploymentprofile.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case deploymentprofile.FieldDescription:
		return m.Description()
	case deploymentprofile.FieldCreateTime:
		return m.CreateTime()
	case deploymentprofile.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deploymentprofile.FieldName:
		return m.OldName(ctx)
	case deploymentprofile.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case deploymentprofile.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case deploymentprofile.FieldDescription:
		return m.OldDescription(ctx)
	case deploymentprofile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case deploymentprofile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown DeploymentProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deploymentprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deploymentprofile.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case deploymentprofile.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case deploymentprofile.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case deploymentprofile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case deploymentprofile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeploymentProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deploymentprofile.FieldDisplayName) {
		fields = append(fields, deploymentprofile.FieldDisplayName)
	}
	if m.FieldCleared(deploymentprofile.FieldDisplayNameLc) {
		fields = append(fields, deploymentprofile.FieldDisplayNameLc)
	}
	if m.FieldCleared(deploymentprofile.FieldDescription) {
		fields = append(fields, deploymentprofile.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentProfileMutation) ClearField(name string) error {
	switch name {
	case deploymentprofile.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case deploymentprofile.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case deploymentprofile.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DeploymentProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentProfileMutation) ResetField(name string) error {
	switch name {
	case deploymentprofile.FieldName:
		m.ResetName()
		return nil
	case deploymentprofile.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case deploymentprofile.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case deploymentprofile.FieldDescription:
		m.ResetDescription()
		return nil
	case deploymentprofile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case deploymentprofile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown DeploymentProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profiles != nil {
		edges = append(edges, deploymentprofile.EdgeProfiles)
	}
	if m.deployment_package_fk != nil {
		edges = append(edges, deploymentprofile.EdgeDeploymentPackageFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deploymentprofile.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.profiles))
		for id := range m.profiles {
			ids = append(ids, id)
		}
		return ids
	case deploymentprofile.EdgeDeploymentPackageFk:
		if id := m.deployment_package_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprofiles != nil {
		edges = append(edges, deploymentprofile.EdgeProfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deploymentprofile.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removedprofiles))
		for id := range m.removedprofiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofiles {
		edges = append(edges, deploymentprofile.EdgeProfiles)
	}
	if m.cleareddeployment_package_fk {
		edges = append(edges, deploymentprofile.EdgeDeploymentPackageFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case deploymentprofile.EdgeProfiles:
		return m.clearedprofiles
	case deploymentprofile.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentProfileMutation) ClearEdge(name string) error {
	switch name {
	case deploymentprofile.EdgeDeploymentPackageFk:
		m.ClearDeploymentPackageFk()
		return nil
	}
	return fmt.Errorf("unknown DeploymentProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentProfileMutation) ResetEdge(name string) error {
	switch name {
	case deploymentprofile.EdgeProfiles:
		m.ResetProfiles()
		return nil
	case deploymentprofile.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	}
	return fmt.Errorf("unknown DeploymentProfile edge %s", name)
}

// DeploymentRequirementMutation represents an operation that mutates the DeploymentRequirement nodes in the graph.
type DeploymentRequirementMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	clearedFields                map[string]struct{}
	profile_fk                   *uint64
	clearedprofile_fk            bool
	deployment_package_fk        *uint64
	cleareddeployment_package_fk bool
	deployment_profile_fk        *uint64
	cleareddeployment_profile_fk bool
	done                         bool
	oldValue                     func(context.Context) (*DeploymentRequirement, error)
	predicates                   []predicate.DeploymentRequirement
}

var _ ent.Mutation = (*DeploymentRequirementMutation)(nil)

// deploymentrequirementOption allows management of the mutation configuration using functional options.
type deploymentrequirementOption func(*DeploymentRequirementMutation)

// newDeploymentRequirementMutation creates new mutation for the DeploymentRequirement entity.
func newDeploymentRequirementMutation(c config, op Op, opts ...deploymentrequirementOption) *DeploymentRequirementMutation {
	m := &DeploymentRequirementMutation{
		config:        c,
		op:            op,
		typ:           TypeDeploymentRequirement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentRequirementID sets the ID field of the mutation.
func withDeploymentRequirementID(id uint64) deploymentrequirementOption {
	return func(m *DeploymentRequirementMutation) {
		var (
			err   error
			once  sync.Once
			value *DeploymentRequirement
		)
		m.oldValue = func(ctx context.Context) (*DeploymentRequirement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeploymentRequirement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeploymentRequirement sets the old DeploymentRequirement of the mutation.
func withDeploymentRequirement(node *DeploymentRequirement) deploymentrequirementOption {
	return func(m *DeploymentRequirementMutation) {
		m.oldValue = func(context.Context) (*DeploymentRequirement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentRequirementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentRequirementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentRequirementMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentRequirementMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeploymentRequirement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProfileFkID sets the "profile_fk" edge to the Profile entity by id.
func (m *DeploymentRequirementMutation) SetProfileFkID(id uint64) {
	m.profile_fk = &id
}

// ClearProfileFk clears the "profile_fk" edge to the Profile entity.
func (m *DeploymentRequirementMutation) ClearProfileFk() {
	m.clearedprofile_fk = true
}

// ProfileFkCleared reports if the "profile_fk" edge to the Profile entity was cleared.
func (m *DeploymentRequirementMutation) ProfileFkCleared() bool {
	return m.clearedprofile_fk
}

// ProfileFkID returns the "profile_fk" edge ID in the mutation.
func (m *DeploymentRequirementMutation) ProfileFkID() (id uint64, exists bool) {
	if m.profile_fk != nil {
		return *m.profile_fk, true
	}
	return
}

// ProfileFkIDs returns the "profile_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileFkID instead. It exists only for internal usage by the builders.
func (m *DeploymentRequirementMutation) ProfileFkIDs() (ids []uint64) {
	if id := m.profile_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfileFk resets all changes to the "profile_fk" edge.
func (m *DeploymentRequirementMutation) ResetProfileFk() {
	m.profile_fk = nil
	m.clearedprofile_fk = false
}

// SetDeploymentPackageFkID sets the "deployment_package_fk" edge to the DeploymentPackage entity by id.
func (m *DeploymentRequirementMutation) SetDeploymentPackageFkID(id uint64) {
	m.deployment_package_fk = &id
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *DeploymentRequirementMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *DeploymentRequirementMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// DeploymentPackageFkID returns the "deployment_package_fk" edge ID in the mutation.
func (m *DeploymentRequirementMutation) DeploymentPackageFkID() (id uint64, exists bool) {
	if m.deployment_package_fk != nil {
		return *m.deployment_package_fk, true
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentPackageFkID instead. It exists only for internal usage by the builders.
func (m *DeploymentRequirementMutation) DeploymentPackageFkIDs() (ids []uint64) {
	if id := m.deployment_package_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *DeploymentRequirementMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
}

// SetDeploymentProfileFkID sets the "deployment_profile_fk" edge to the DeploymentProfile entity by id.
func (m *DeploymentRequirementMutation) SetDeploymentProfileFkID(id uint64) {
	m.deployment_profile_fk = &id
}

// ClearDeploymentProfileFk clears the "deployment_profile_fk" edge to the DeploymentProfile entity.
func (m *DeploymentRequirementMutation) ClearDeploymentProfileFk() {
	m.cleareddeployment_profile_fk = true
}

// DeploymentProfileFkCleared reports if the "deployment_profile_fk" edge to the DeploymentProfile entity was cleared.
func (m *DeploymentRequirementMutation) DeploymentProfileFkCleared() bool {
	return m.cleareddeployment_profile_fk
}

// DeploymentProfileFkID returns the "deployment_profile_fk" edge ID in the mutation.
func (m *DeploymentRequirementMutation) DeploymentProfileFkID() (id uint64, exists bool) {
	if m.deployment_profile_fk != nil {
		return *m.deployment_profile_fk, true
	}
	return
}

// DeploymentProfileFkIDs returns the "deployment_profile_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentProfileFkID instead. It exists only for internal usage by the builders.
func (m *DeploymentRequirementMutation) DeploymentProfileFkIDs() (ids []uint64) {
	if id := m.deployment_profile_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentProfileFk resets all changes to the "deployment_profile_fk" edge.
func (m *DeploymentRequirementMutation) ResetDeploymentProfileFk() {
	m.deployment_profile_fk = nil
	m.cleareddeployment_profile_fk = false
}

// Where appends a list predicates to the DeploymentRequirementMutation builder.
func (m *DeploymentRequirementMutation) Where(ps ...predicate.DeploymentRequirement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentRequirementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentRequirementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeploymentRequirement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentRequirementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentRequirementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeploymentRequirement).
func (m *DeploymentRequirementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentRequirementMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentRequirementMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentRequirementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown DeploymentRequirement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentRequirementMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeploymentRequirement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentRequirementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentRequirementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentRequirementMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown DeploymentRequirement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentRequirementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentRequirementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentRequirementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeploymentRequirement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentRequirementMutation) ResetField(name string) error {
	return fmt.Errorf("unknown DeploymentRequirement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentRequirementMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.profile_fk != nil {
		edges = append(edges, deploymentrequirement.EdgeProfileFk)
	}
	if m.deployment_package_fk != nil {
		edges = append(edges, deploymentrequirement.EdgeDeploymentPackageFk)
	}
	if m.deployment_profile_fk != nil {
		edges = append(edges, deploymentrequirement.EdgeDeploymentProfileFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentRequirementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deploymentrequirement.EdgeProfileFk:
		if id := m.profile_fk; id != nil {
			return []ent.Value{*id}
		}
	case deploymentrequirement.EdgeDeploymentPackageFk:
		if id := m.deployment_package_fk; id != nil {
			return []ent.Value{*id}
		}
	case deploymentrequirement.EdgeDeploymentProfileFk:
		if id := m.deployment_profile_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentRequirementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentRequirementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentRequirementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprofile_fk {
		edges = append(edges, deploymentrequirement.EdgeProfileFk)
	}
	if m.cleareddeployment_package_fk {
		edges = append(edges, deploymentrequirement.EdgeDeploymentPackageFk)
	}
	if m.cleareddeployment_profile_fk {
		edges = append(edges, deploymentrequirement.EdgeDeploymentProfileFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentRequirementMutation) EdgeCleared(name string) bool {
	switch name {
	case deploymentrequirement.EdgeProfileFk:
		return m.clearedprofile_fk
	case deploymentrequirement.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	case deploymentrequirement.EdgeDeploymentProfileFk:
		return m.cleareddeployment_profile_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentRequirementMutation) ClearEdge(name string) error {
	switch name {
	case deploymentrequirement.EdgeProfileFk:
		m.ClearProfileFk()
		return nil
	case deploymentrequirement.EdgeDeploymentPackageFk:
		m.ClearDeploymentPackageFk()
		return nil
	case deploymentrequirement.EdgeDeploymentProfileFk:
		m.ClearDeploymentProfileFk()
		return nil
	}
	return fmt.Errorf("unknown DeploymentRequirement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentRequirementMutation) ResetEdge(name string) error {
	switch name {
	case deploymentrequirement.EdgeProfileFk:
		m.ResetProfileFk()
		return nil
	case deploymentrequirement.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	case deploymentrequirement.EdgeDeploymentProfileFk:
		m.ResetDeploymentProfileFk()
		return nil
	}
	return fmt.Errorf("unknown DeploymentRequirement edge %s", name)
}

// EndpointMutation represents an operation that mutates the Endpoint nodes in the graph.
type EndpointMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	service_name        *string
	external_path       *string
	internal_path       *string
	scheme              *string
	auth_type           *string
	app_name            *string
	clearedFields       map[string]struct{}
	extension_fk        *uint64
	clearedextension_fk bool
	done                bool
	oldValue            func(context.Context) (*Endpoint, error)
	predicates          []predicate.Endpoint
}

var _ ent.Mutation = (*EndpointMutation)(nil)

// endpointOption allows management of the mutation configuration using functional options.
type endpointOption func(*EndpointMutation)

// newEndpointMutation creates new mutation for the Endpoint entity.
func newEndpointMutation(c config, op Op, opts ...endpointOption) *EndpointMutation {
	m := &EndpointMutation{
		config:        c,
		op:            op,
		typ:           TypeEndpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEndpointID sets the ID field of the mutation.
func withEndpointID(id uint64) endpointOption {
	return func(m *EndpointMutation) {
		var (
			err   error
			once  sync.Once
			value *Endpoint
		)
		m.oldValue = func(ctx context.Context) (*Endpoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Endpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEndpoint sets the old Endpoint of the mutation.
func withEndpoint(node *Endpoint) endpointOption {
	return func(m *EndpointMutation) {
		m.oldValue = func(context.Context) (*Endpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EndpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EndpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EndpointMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EndpointMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Endpoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetServiceName sets the "service_name" field.
func (m *EndpointMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *EndpointMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *EndpointMutation) ResetServiceName() {
	m.service_name = nil
}

// SetExternalPath sets the "external_path" field.
func (m *EndpointMutation) SetExternalPath(s string) {
	m.external_path = &s
}

// ExternalPath returns the value of the "external_path" field in the mutation.
func (m *EndpointMutation) ExternalPath() (r string, exists bool) {
	v := m.external_path
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalPath returns the old "external_path" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldExternalPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalPath: %w", err)
	}
	return oldValue.ExternalPath, nil
}

// ResetExternalPath resets all changes to the "external_path" field.
func (m *EndpointMutation) ResetExternalPath() {
	m.external_path = nil
}

// SetInternalPath sets the "internal_path" field.
func (m *EndpointMutation) SetInternalPath(s string) {
	m.internal_path = &s
}

// InternalPath returns the value of the "internal_path" field in the mutation.
func (m *EndpointMutation) InternalPath() (r string, exists bool) {
	v := m.internal_path
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalPath returns the old "internal_path" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldInternalPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalPath: %w", err)
	}
	return oldValue.InternalPath, nil
}

// ResetInternalPath resets all changes to the "internal_path" field.
func (m *EndpointMutation) ResetInternalPath() {
	m.internal_path = nil
}

// SetScheme sets the "scheme" field.
func (m *EndpointMutation) SetScheme(s string) {
	m.scheme = &s
}

// Scheme returns the value of the "scheme" field in the mutation.
func (m *EndpointMutation) Scheme() (r string, exists bool) {
	v := m.scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldScheme returns the old "scheme" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldScheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheme: %w", err)
	}
	return oldValue.Scheme, nil
}

// ResetScheme resets all changes to the "scheme" field.
func (m *EndpointMutation) ResetScheme() {
	m.scheme = nil
}

// SetAuthType sets the "auth_type" field.
func (m *EndpointMutation) SetAuthType(s string) {
	m.auth_type = &s
}

// AuthType returns the value of the "auth_type" field in the mutation.
func (m *EndpointMutation) AuthType() (r string, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old "auth_type" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldAuthType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType resets all changes to the "auth_type" field.
func (m *EndpointMutation) ResetAuthType() {
	m.auth_type = nil
}

// SetAppName sets the "app_name" field.
func (m *EndpointMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *EndpointMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ClearAppName clears the value of the "app_name" field.
func (m *EndpointMutation) ClearAppName() {
	m.app_name = nil
	m.clearedFields[endpoint.FieldAppName] = struct{}{}
}

// AppNameCleared returns if the "app_name" field was cleared in this mutation.
func (m *EndpointMutation) AppNameCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldAppName]
	return ok
}

// ResetAppName resets all changes to the "app_name" field.
func (m *EndpointMutation) ResetAppName() {
	m.app_name = nil
	delete(m.clearedFields, endpoint.FieldAppName)
}

// SetExtensionFkID sets the "extension_fk" edge to the Extension entity by id.
func (m *EndpointMutation) SetExtensionFkID(id uint64) {
	m.extension_fk = &id
}

// ClearExtensionFk clears the "extension_fk" edge to the Extension entity.
func (m *EndpointMutation) ClearExtensionFk() {
	m.clearedextension_fk = true
}

// ExtensionFkCleared reports if the "extension_fk" edge to the Extension entity was cleared.
func (m *EndpointMutation) ExtensionFkCleared() bool {
	return m.clearedextension_fk
}

// ExtensionFkID returns the "extension_fk" edge ID in the mutation.
func (m *EndpointMutation) ExtensionFkID() (id uint64, exists bool) {
	if m.extension_fk != nil {
		return *m.extension_fk, true
	}
	return
}

// ExtensionFkIDs returns the "extension_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExtensionFkID instead. It exists only for internal usage by the builders.
func (m *EndpointMutation) ExtensionFkIDs() (ids []uint64) {
	if id := m.extension_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtensionFk resets all changes to the "extension_fk" edge.
func (m *EndpointMutation) ResetExtensionFk() {
	m.extension_fk = nil
	m.clearedextension_fk = false
}

// Where appends a list predicates to the EndpointMutation builder.
func (m *EndpointMutation) Where(ps ...predicate.Endpoint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EndpointMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EndpointMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Endpoint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EndpointMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EndpointMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Endpoint).
func (m *EndpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EndpointMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.service_name != nil {
		fields = append(fields, endpoint.FieldServiceName)
	}
	if m.external_path != nil {
		fields = append(fields, endpoint.FieldExternalPath)
	}
	if m.internal_path != nil {
		fields = append(fields, endpoint.FieldInternalPath)
	}
	if m.scheme != nil {
		fields = append(fields, endpoint.FieldScheme)
	}
	if m.auth_type != nil {
		fields = append(fields, endpoint.FieldAuthType)
	}
	if m.app_name != nil {
		fields = append(fields, endpoint.FieldAppName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EndpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case endpoint.FieldServiceName:
		return m.ServiceName()
	case endpoint.FieldExternalPath:
		return m.ExternalPath()
	case endpoint.FieldInternalPath:
		return m.InternalPath()
	case endpoint.FieldScheme:
		return m.Scheme()
	case endpoint.FieldAuthType:
		return m.AuthType()
	case endpoint.FieldAppName:
		return m.AppName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EndpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case endpoint.FieldServiceName:
		return m.OldServiceName(ctx)
	case endpoint.FieldExternalPath:
		return m.OldExternalPath(ctx)
	case endpoint.FieldInternalPath:
		return m.OldInternalPath(ctx)
	case endpoint.FieldScheme:
		return m.OldScheme(ctx)
	case endpoint.FieldAuthType:
		return m.OldAuthType(ctx)
	case endpoint.FieldAppName:
		return m.OldAppName(ctx)
	}
	return nil, fmt.Errorf("unknown Endpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case endpoint.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case endpoint.FieldExternalPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalPath(v)
		return nil
	case endpoint.FieldInternalPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalPath(v)
		return nil
	case endpoint.FieldScheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheme(v)
		return nil
	case endpoint.FieldAuthType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	case endpoint.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EndpointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EndpointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Endpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EndpointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(endpoint.FieldAppName) {
		fields = append(fields, endpoint.FieldAppName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EndpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EndpointMutation) ClearField(name string) error {
	switch name {
	case endpoint.FieldAppName:
		m.ClearAppName()
		return nil
	}
	return fmt.Errorf("unknown Endpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EndpointMutation) ResetField(name string) error {
	switch name {
	case endpoint.FieldServiceName:
		m.ResetServiceName()
		return nil
	case endpoint.FieldExternalPath:
		m.ResetExternalPath()
		return nil
	case endpoint.FieldInternalPath:
		m.ResetInternalPath()
		return nil
	case endpoint.FieldScheme:
		m.ResetScheme()
		return nil
	case endpoint.FieldAuthType:
		m.ResetAuthType()
		return nil
	case endpoint.FieldAppName:
		m.ResetAppName()
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EndpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.extension_fk != nil {
		edges = append(edges, endpoint.EdgeExtensionFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EndpointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case endpoint.EdgeExtensionFk:
		if id := m.extension_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EndpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EndpointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EndpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedextension_fk {
		edges = append(edges, endpoint.EdgeExtensionFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EndpointMutation) EdgeCleared(name string) bool {
	switch name {
	case endpoint.EdgeExtensionFk:
		return m.clearedextension_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EndpointMutation) ClearEdge(name string) error {
	switch name {
	case endpoint.EdgeExtensionFk:
		m.ClearExtensionFk()
		return nil
	}
	return fmt.Errorf("unknown Endpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EndpointMutation) ResetEdge(name string) error {
	switch name {
	case endpoint.EdgeExtensionFk:
		m.ResetExtensionFk()
		return nil
	}
	return fmt.Errorf("unknown Endpoint edge %s", name)
}

// ExtensionMutation represents an operation that mutates the Extension nodes in the graph.
type ExtensionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	name                         *string
	version                      *string
	display_name                 *string
	display_name_lc              *string
	description                  *string
	ui_label                     *string
	ui_service_name              *string
	ui_description               *string
	ui_file_name                 *string
	ui_app_name                  *string
	ui_module_name               *string
	clearedFields                map[string]struct{}
	endpoints                    map[uint64]struct{}
	removedendpoints             map[uint64]struct{}
	clearedendpoints             bool
	deployment_package_fk        *uint64
	cleareddeployment_package_fk bool
	done                         bool
	oldValue                     func(context.Context) (*Extension, error)
	predicates                   []predicate.Extension
}

var _ ent.Mutation = (*ExtensionMutation)(nil)

// extensionOption allows management of the mutation configuration using functional options.
type extensionOption func(*ExtensionMutation)

// newExtensionMutation creates new mutation for the Extension entity.
func newExtensionMutation(c config, op Op, opts ...extensionOption) *ExtensionMutation {
	m := &ExtensionMutation{
		config:        c,
		op:            op,
		typ:           TypeExtension,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtensionID sets the ID field of the mutation.
func withExtensionID(id uint64) extensionOption {
	return func(m *ExtensionMutation) {
		var (
			err   error
			once  sync.Once
			value *Extension
		)
		m.oldValue = func(ctx context.Context) (*Extension, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Extension.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtension sets the old Extension of the mutation.
func withExtension(node *Extension) extensionOption {
	return func(m *ExtensionMutation) {
		m.oldValue = func(context.Context) (*Extension, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtensionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtensionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtensionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtensionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Extension.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ExtensionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExtensionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExtensionMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *ExtensionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ExtensionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ExtensionMutation) ResetVersion() {
	m.version = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ExtensionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ExtensionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ExtensionMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[extension.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ExtensionMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[extension.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ExtensionMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, extension.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *ExtensionMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *ExtensionMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *ExtensionMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[extension.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *ExtensionMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[extension.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *ExtensionMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, extension.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *ExtensionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ExtensionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ExtensionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[extension.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ExtensionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[extension.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ExtensionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, extension.FieldDescription)
}

// SetUILabel sets the "ui_label" field.
func (m *ExtensionMutation) SetUILabel(s string) {
	m.ui_label = &s
}

// UILabel returns the value of the "ui_label" field in the mutation.
func (m *ExtensionMutation) UILabel() (r string, exists bool) {
	v := m.ui_label
	if v == nil {
		return
	}
	return *v, true
}

// OldUILabel returns the old "ui_label" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldUILabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUILabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUILabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUILabel: %w", err)
	}
	return oldValue.UILabel, nil
}

// ClearUILabel clears the value of the "ui_label" field.
func (m *ExtensionMutation) ClearUILabel() {
	m.ui_label = nil
	m.clearedFields[extension.FieldUILabel] = struct{}{}
}

// UILabelCleared returns if the "ui_label" field was cleared in this mutation.
func (m *ExtensionMutation) UILabelCleared() bool {
	_, ok := m.clearedFields[extension.FieldUILabel]
	return ok
}

// ResetUILabel resets all changes to the "ui_label" field.
func (m *ExtensionMutation) ResetUILabel() {
	m.ui_label = nil
	delete(m.clearedFields, extension.FieldUILabel)
}

// SetUIServiceName sets the "ui_service_name" field.
func (m *ExtensionMutation) SetUIServiceName(s string) {
	m.ui_service_name = &s
}

// UIServiceName returns the value of the "ui_service_name" field in the mutation.
func (m *ExtensionMutation) UIServiceName() (r string, exists bool) {
	v := m.ui_service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUIServiceName returns the old "ui_service_name" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldUIServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUIServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUIServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUIServiceName: %w", err)
	}
	return oldValue.UIServiceName, nil
}

// ClearUIServiceName clears the value of the "ui_service_name" field.
func (m *ExtensionMutation) ClearUIServiceName() {
	m.ui_service_name = nil
	m.clearedFields[extension.FieldUIServiceName] = struct{}{}
}

// UIServiceNameCleared returns if the "ui_service_name" field was cleared in this mutation.
func (m *ExtensionMutation) UIServiceNameCleared() bool {
	_, ok := m.clearedFields[extension.FieldUIServiceName]
	return ok
}

// ResetUIServiceName resets all changes to the "ui_service_name" field.
func (m *ExtensionMutation) ResetUIServiceName() {
	m.ui_service_name = nil
	delete(m.clearedFields, extension.FieldUIServiceName)
}

// SetUIDescription sets the "ui_description" field.
func (m *ExtensionMutation) SetUIDescription(s string) {
	m.ui_description = &s
}

// UIDescription returns the value of the "ui_description" field in the mutation.
func (m *ExtensionMutation) UIDescription() (r string, exists bool) {
	v := m.ui_description
	if v == nil {
		return
	}
	return *v, true
}

// OldUIDescription returns the old "ui_description" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldUIDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUIDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUIDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUIDescription: %w", err)
	}
	return oldValue.UIDescription, nil
}

// ClearUIDescription clears the value of the "ui_description" field.
func (m *ExtensionMutation) ClearUIDescription() {
	m.ui_description = nil
	m.clearedFields[extension.FieldUIDescription] = struct{}{}
}

// UIDescriptionCleared returns if the "ui_description" field was cleared in this mutation.
func (m *ExtensionMutation) UIDescriptionCleared() bool {
	_, ok := m.clearedFields[extension.FieldUIDescription]
	return ok
}

// ResetUIDescription resets all changes to the "ui_description" field.
func (m *ExtensionMutation) ResetUIDescription() {
	m.ui_description = nil
	delete(m.clearedFields, extension.FieldUIDescription)
}

// SetUIFileName sets the "ui_file_name" field.
func (m *ExtensionMutation) SetUIFileName(s string) {
	m.ui_file_name = &s
}

// UIFileName returns the value of the "ui_file_name" field in the mutation.
func (m *ExtensionMutation) UIFileName() (r string, exists bool) {
	v := m.ui_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUIFileName returns the old "ui_file_name" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldUIFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUIFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUIFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUIFileName: %w", err)
	}
	return oldValue.UIFileName, nil
}

// ClearUIFileName clears the value of the "ui_file_name" field.
func (m *ExtensionMutation) ClearUIFileName() {
	m.ui_file_name = nil
	m.clearedFields[extension.FieldUIFileName] = struct{}{}
}

// UIFileNameCleared returns if the "ui_file_name" field was cleared in this mutation.
func (m *ExtensionMutation) UIFileNameCleared() bool {
	_, ok := m.clearedFields[extension.FieldUIFileName]
	return ok
}

// ResetUIFileName resets all changes to the "ui_file_name" field.
func (m *ExtensionMutation) ResetUIFileName() {
	m.ui_file_name = nil
	delete(m.clearedFields, extension.FieldUIFileName)
}

// SetUIAppName sets the "ui_app_name" field.
func (m *ExtensionMutation) SetUIAppName(s string) {
	m.ui_app_name = &s
}

// UIAppName returns the value of the "ui_app_name" field in the mutation.
func (m *ExtensionMutation) UIAppName() (r string, exists bool) {
	v := m.ui_app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUIAppName returns the old "ui_app_name" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldUIAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUIAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUIAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUIAppName: %w", err)
	}
	return oldValue.UIAppName, nil
}

// ClearUIAppName clears the value of the "ui_app_name" field.
func (m *ExtensionMutation) ClearUIAppName() {
	m.ui_app_name = nil
	m.clearedFields[extension.FieldUIAppName] = struct{}{}
}

// UIAppNameCleared returns if the "ui_app_name" field was cleared in this mutation.
func (m *ExtensionMutation) UIAppNameCleared() bool {
	_, ok := m.clearedFields[extension.FieldUIAppName]
	return ok
}

// ResetUIAppName resets all changes to the "ui_app_name" field.
func (m *ExtensionMutation) ResetUIAppName() {
	m.ui_app_name = nil
	delete(m.clearedFields, extension.FieldUIAppName)
}

// SetUIModuleName sets the "ui_module_name" field.
func (m *ExtensionMutation) SetUIModuleName(s string) {
	m.ui_module_name = &s
}

// UIModuleName returns the value of the "ui_module_name" field in the mutation.
func (m *ExtensionMutation) UIModuleName() (r string, exists bool) {
	v := m.ui_module_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUIModuleName returns the old "ui_module_name" field's value of the Extension entity.
// If the Extension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtensionMutation) OldUIModuleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUIModuleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUIModuleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUIModuleName: %w", err)
	}
	return oldValue.UIModuleName, nil
}

// ClearUIModuleName clears the value of the "ui_module_name" field.
func (m *ExtensionMutation) ClearUIModuleName() {
	m.ui_module_name = nil
	m.clearedFields[extension.FieldUIModuleName] = struct{}{}
}

// UIModuleNameCleared returns if the "ui_module_name" field was cleared in this mutation.
func (m *ExtensionMutation) UIModuleNameCleared() bool {
	_, ok := m.clearedFields[extension.FieldUIModuleName]
	return ok
}

// ResetUIModuleName resets all changes to the "ui_module_name" field.
func (m *ExtensionMutation) ResetUIModuleName() {
	m.ui_module_name = nil
	delete(m.clearedFields, extension.FieldUIModuleName)
}

// AddEndpointIDs adds the "endpoints" edge to the Endpoint entity by ids.
func (m *ExtensionMutation) AddEndpointIDs(ids ...uint64) {
	if m.endpoints == nil {
		m.endpoints = make(map[uint64]struct{})
	}
	for i := range ids {
		m.endpoints[ids[i]] = struct{}{}
	}
}

// ClearEndpoints clears the "endpoints" edge to the Endpoint entity.
func (m *ExtensionMutation) ClearEndpoints() {
	m.clearedendpoints = true
}

// EndpointsCleared reports if the "endpoints" edge to the Endpoint entity was cleared.
func (m *ExtensionMutation) EndpointsCleared() bool {
	return m.clearedendpoints
}

// RemoveEndpointIDs removes the "endpoints" edge to the Endpoint entity by IDs.
func (m *ExtensionMutation) RemoveEndpointIDs(ids ...uint64) {
	if m.removedendpoints == nil {
		m.removedendpoints = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.endpoints, ids[i])
		m.removedendpoints[ids[i]] = struct{}{}
	}
}

// RemovedEndpoints returns the removed IDs of the "endpoints" edge to the Endpoint entity.
func (m *ExtensionMutation) RemovedEndpointsIDs() (ids []uint64) {
	for id := range m.removedendpoints {
		ids = append(ids, id)
	}
	return
}

// EndpointsIDs returns the "endpoints" edge IDs in the mutation.
func (m *ExtensionMutation) EndpointsIDs() (ids []uint64) {
	for id := range m.endpoints {
		ids = append(ids, id)
	}
	return
}

// ResetEndpoints resets all changes to the "endpoints" edge.
func (m *ExtensionMutation) ResetEndpoints() {
	m.endpoints = nil
	m.clearedendpoints = false
	m.removedendpoints = nil
}

// SetDeploymentPackageFkID sets the "deployment_package_fk" edge to the DeploymentPackage entity by id.
func (m *ExtensionMutation) SetDeploymentPackageFkID(id uint64) {
	m.deployment_package_fk = &id
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *ExtensionMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *ExtensionMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// DeploymentPackageFkID returns the "deployment_package_fk" edge ID in the mutation.
func (m *ExtensionMutation) DeploymentPackageFkID() (id uint64, exists bool) {
	if m.deployment_package_fk != nil {
		return *m.deployment_package_fk, true
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentPackageFkID instead. It exists only for internal usage by the builders.
func (m *ExtensionMutation) DeploymentPackageFkIDs() (ids []uint64) {
	if id := m.deployment_package_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *ExtensionMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
}

// Where appends a list predicates to the ExtensionMutation builder.
func (m *ExtensionMutation) Where(ps ...predicate.Extension) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtensionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtensionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Extension, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtensionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtensionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Extension).
func (m *ExtensionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtensionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, extension.FieldName)
	}
	if m.version != nil {
		fields = append(fields, extension.FieldVersion)
	}
	if m.display_name != nil {
		fields = append(fields, extension.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, extension.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, extension.FieldDescription)
	}
	if m.ui_label != nil {
		fields = append(fields, extension.FieldUILabel)
	}
	if m.ui_service_name != nil {
		fields = append(fields, extension.FieldUIServiceName)
	}
	if m.ui_description != nil {
		fields = append(fields, extension.FieldUIDescription)
	}
	if m.ui_file_name != nil {
		fields = append(fields, extension.FieldUIFileName)
	}
	if m.ui_app_name != nil {
		fields = append(fields, extension.FieldUIAppName)
	}
	if m.ui_module_name != nil {
		fields = append(fields, extension.FieldUIModuleName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtensionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extension.FieldName:
		return m.Name()
	case extension.FieldVersion:
		return m.Version()
	case extension.FieldDisplayName:
		return m.DisplayName()
	case extension.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case extension.FieldDescription:
		return m.Description()
	case extension.FieldUILabel:
		return m.UILabel()
	case extension.FieldUIServiceName:
		return m.UIServiceName()
	case extension.FieldUIDescription:
		return m.UIDescription()
	case extension.FieldUIFileName:
		return m.UIFileName()
	case extension.FieldUIAppName:
		return m.UIAppName()
	case extension.FieldUIModuleName:
		return m.UIModuleName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtensionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extension.FieldName:
		return m.OldName(ctx)
	case extension.FieldVersion:
		return m.OldVersion(ctx)
	case extension.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case extension.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case extension.FieldDescription:
		return m.OldDescription(ctx)
	case extension.FieldUILabel:
		return m.OldUILabel(ctx)
	case extension.FieldUIServiceName:
		return m.OldUIServiceName(ctx)
	case extension.FieldUIDescription:
		return m.OldUIDescription(ctx)
	case extension.FieldUIFileName:
		return m.OldUIFileName(ctx)
	case extension.FieldUIAppName:
		return m.OldUIAppName(ctx)
	case extension.FieldUIModuleName:
		return m.OldUIModuleName(ctx)
	}
	return nil, fmt.Errorf("unknown Extension field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtensionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extension.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case extension.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case extension.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case extension.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case extension.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case extension.FieldUILabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUILabel(v)
		return nil
	case extension.FieldUIServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUIServiceName(v)
		return nil
	case extension.FieldUIDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUIDescription(v)
		return nil
	case extension.FieldUIFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUIFileName(v)
		return nil
	case extension.FieldUIAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUIAppName(v)
		return nil
	case extension.FieldUIModuleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUIModuleName(v)
		return nil
	}
	return fmt.Errorf("unknown Extension field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtensionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtensionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtensionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Extension numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtensionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extension.FieldDisplayName) {
		fields = append(fields, extension.FieldDisplayName)
	}
	if m.FieldCleared(extension.FieldDisplayNameLc) {
		fields = append(fields, extension.FieldDisplayNameLc)
	}
	if m.FieldCleared(extension.FieldDescription) {
		fields = append(fields, extension.FieldDescription)
	}
	if m.FieldCleared(extension.FieldUILabel) {
		fields = append(fields, extension.FieldUILabel)
	}
	if m.FieldCleared(extension.FieldUIServiceName) {
		fields = append(fields, extension.FieldUIServiceName)
	}
	if m.FieldCleared(extension.FieldUIDescription) {
		fields = append(fields, extension.FieldUIDescription)
	}
	if m.FieldCleared(extension.FieldUIFileName) {
		fields = append(fields, extension.FieldUIFileName)
	}
	if m.FieldCleared(extension.FieldUIAppName) {
		fields = append(fields, extension.FieldUIAppName)
	}
	if m.FieldCleared(extension.FieldUIModuleName) {
		fields = append(fields, extension.FieldUIModuleName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtensionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtensionMutation) ClearField(name string) error {
	switch name {
	case extension.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case extension.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case extension.FieldDescription:
		m.ClearDescription()
		return nil
	case extension.FieldUILabel:
		m.ClearUILabel()
		return nil
	case extension.FieldUIServiceName:
		m.ClearUIServiceName()
		return nil
	case extension.FieldUIDescription:
		m.ClearUIDescription()
		return nil
	case extension.FieldUIFileName:
		m.ClearUIFileName()
		return nil
	case extension.FieldUIAppName:
		m.ClearUIAppName()
		return nil
	case extension.FieldUIModuleName:
		m.ClearUIModuleName()
		return nil
	}
	return fmt.Errorf("unknown Extension nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtensionMutation) ResetField(name string) error {
	switch name {
	case extension.FieldName:
		m.ResetName()
		return nil
	case extension.FieldVersion:
		m.ResetVersion()
		return nil
	case extension.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case extension.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case extension.FieldDescription:
		m.ResetDescription()
		return nil
	case extension.FieldUILabel:
		m.ResetUILabel()
		return nil
	case extension.FieldUIServiceName:
		m.ResetUIServiceName()
		return nil
	case extension.FieldUIDescription:
		m.ResetUIDescription()
		return nil
	case extension.FieldUIFileName:
		m.ResetUIFileName()
		return nil
	case extension.FieldUIAppName:
		m.ResetUIAppName()
		return nil
	case extension.FieldUIModuleName:
		m.ResetUIModuleName()
		return nil
	}
	return fmt.Errorf("unknown Extension field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtensionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.endpoints != nil {
		edges = append(edges, extension.EdgeEndpoints)
	}
	if m.deployment_package_fk != nil {
		edges = append(edges, extension.EdgeDeploymentPackageFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtensionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extension.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.endpoints))
		for id := range m.endpoints {
			ids = append(ids, id)
		}
		return ids
	case extension.EdgeDeploymentPackageFk:
		if id := m.deployment_package_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtensionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedendpoints != nil {
		edges = append(edges, extension.EdgeEndpoints)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtensionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case extension.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.removedendpoints))
		for id := range m.removedendpoints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtensionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedendpoints {
		edges = append(edges, extension.EdgeEndpoints)
	}
	if m.cleareddeployment_package_fk {
		edges = append(edges, extension.EdgeDeploymentPackageFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtensionMutation) EdgeCleared(name string) bool {
	switch name {
	case extension.EdgeEndpoints:
		return m.clearedendpoints
	case extension.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtensionMutation) ClearEdge(name string) error {
	switch name {
	case extension.EdgeDeploymentPackageFk:
		m.ClearDeploymentPackageFk()
		return nil
	}
	return fmt.Errorf("unknown Extension unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtensionMutation) ResetEdge(name string) error {
	switch name {
	case extension.EdgeEndpoints:
		m.ResetEndpoints()
		return nil
	case extension.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	}
	return fmt.Errorf("unknown Extension edge %s", name)
}

// IgnoredResourceMutation represents an operation that mutates the IgnoredResource nodes in the graph.
type IgnoredResourceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	name                  *string
	kind                  *string
	namespace             *string
	clearedFields         map[string]struct{}
	application_fk        *uint64
	clearedapplication_fk bool
	done                  bool
	oldValue              func(context.Context) (*IgnoredResource, error)
	predicates            []predicate.IgnoredResource
}

var _ ent.Mutation = (*IgnoredResourceMutation)(nil)

// ignoredresourceOption allows management of the mutation configuration using functional options.
type ignoredresourceOption func(*IgnoredResourceMutation)

// newIgnoredResourceMutation creates new mutation for the IgnoredResource entity.
func newIgnoredResourceMutation(c config, op Op, opts ...ignoredresourceOption) *IgnoredResourceMutation {
	m := &IgnoredResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeIgnoredResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIgnoredResourceID sets the ID field of the mutation.
func withIgnoredResourceID(id uint64) ignoredresourceOption {
	return func(m *IgnoredResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *IgnoredResource
		)
		m.oldValue = func(ctx context.Context) (*IgnoredResource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IgnoredResource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIgnoredResource sets the old IgnoredResource of the mutation.
func withIgnoredResource(node *IgnoredResource) ignoredresourceOption {
	return func(m *IgnoredResourceMutation) {
		m.oldValue = func(context.Context) (*IgnoredResource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IgnoredResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IgnoredResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IgnoredResourceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IgnoredResourceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IgnoredResource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IgnoredResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IgnoredResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IgnoredResource entity.
// If the IgnoredResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoredResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IgnoredResourceMutation) ResetName() {
	m.name = nil
}

// SetKind sets the "kind" field.
func (m *IgnoredResourceMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IgnoredResourceMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the IgnoredResource entity.
// If the IgnoredResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoredResourceMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *IgnoredResourceMutation) ResetKind() {
	m.kind = nil
}

// SetNamespace sets the "namespace" field.
func (m *IgnoredResourceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *IgnoredResourceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the IgnoredResource entity.
// If the IgnoredResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoredResourceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *IgnoredResourceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetApplicationFkID sets the "application_fk" edge to the Application entity by id.
func (m *IgnoredResourceMutation) SetApplicationFkID(id uint64) {
	m.application_fk = &id
}

// ClearApplicationFk clears the "application_fk" edge to the Application entity.
func (m *IgnoredResourceMutation) ClearApplicationFk() {
	m.clearedapplication_fk = true
}

// ApplicationFkCleared reports if the "application_fk" edge to the Application entity was cleared.
func (m *IgnoredResourceMutation) ApplicationFkCleared() bool {
	return m.clearedapplication_fk
}

// ApplicationFkID returns the "application_fk" edge ID in the mutation.
func (m *IgnoredResourceMutation) ApplicationFkID() (id uint64, exists bool) {
	if m.application_fk != nil {
		return *m.application_fk, true
	}
	return
}

// ApplicationFkIDs returns the "application_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationFkID instead. It exists only for internal usage by the builders.
func (m *IgnoredResourceMutation) ApplicationFkIDs() (ids []uint64) {
	if id := m.application_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicationFk resets all changes to the "application_fk" edge.
func (m *IgnoredResourceMutation) ResetApplicationFk() {
	m.application_fk = nil
	m.clearedapplication_fk = false
}

// Where appends a list predicates to the IgnoredResourceMutation builder.
func (m *IgnoredResourceMutation) Where(ps ...predicate.IgnoredResource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IgnoredResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IgnoredResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IgnoredResource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IgnoredResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IgnoredResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IgnoredResource).
func (m *IgnoredResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IgnoredResourceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, ignoredresource.FieldName)
	}
	if m.kind != nil {
		fields = append(fields, ignoredresource.FieldKind)
	}
	if m.namespace != nil {
		fields = append(fields, ignoredresource.FieldNamespace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IgnoredResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ignoredresource.FieldName:
		return m.Name()
	case ignoredresource.FieldKind:
		return m.Kind()
	case ignoredresource.FieldNamespace:
		return m.Namespace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IgnoredResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ignoredresource.FieldName:
		return m.OldName(ctx)
	case ignoredresource.FieldKind:
		return m.OldKind(ctx)
	case ignoredresource.FieldNamespace:
		return m.OldNamespace(ctx)
	}
	return nil, fmt.Errorf("unknown IgnoredResource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IgnoredResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ignoredresource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ignoredresource.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case ignoredresource.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	}
	return fmt.Errorf("unknown IgnoredResource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IgnoredResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IgnoredResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IgnoredResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IgnoredResource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IgnoredResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IgnoredResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IgnoredResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IgnoredResource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IgnoredResourceMutation) ResetField(name string) error {
	switch name {
	case ignoredresource.FieldName:
		m.ResetName()
		return nil
	case ignoredresource.FieldKind:
		m.ResetKind()
		return nil
	case ignoredresource.FieldNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown IgnoredResource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IgnoredResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.application_fk != nil {
		edges = append(edges, ignoredresource.EdgeApplicationFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IgnoredResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ignoredresource.EdgeApplicationFk:
		if id := m.application_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IgnoredResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IgnoredResourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IgnoredResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplication_fk {
		edges = append(edges, ignoredresource.EdgeApplicationFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IgnoredResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case ignoredresource.EdgeApplicationFk:
		return m.clearedapplication_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IgnoredResourceMutation) ClearEdge(name string) error {
	switch name {
	case ignoredresource.EdgeApplicationFk:
		m.ClearApplicationFk()
		return nil
	}
	return fmt.Errorf("unknown IgnoredResource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IgnoredResourceMutation) ResetEdge(name string) error {
	switch name {
	case ignoredresource.EdgeApplicationFk:
		m.ResetApplicationFk()
		return nil
	}
	return fmt.Errorf("unknown IgnoredResource edge %s", name)
}

// NamespaceMutation represents an operation that mutates the Namespace nodes in the graph.
type NamespaceMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	name                         *string
	clearedFields                map[string]struct{}
	deployment_package_fk        *uint64
	cleareddeployment_package_fk bool
	adornments                   map[uint64]struct{}
	removedadornments            map[uint64]struct{}
	clearedadornments            bool
	done                         bool
	oldValue                     func(context.Context) (*Namespace, error)
	predicates                   []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows management of the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for the Namespace entity.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the ID field of the mutation.
func withNamespaceID(id uint64) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Namespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NamespaceMutation) ResetName() {
	m.name = nil
}

// SetDeploymentPackageFkID sets the "deployment_package_fk" edge to the DeploymentPackage entity by id.
func (m *NamespaceMutation) SetDeploymentPackageFkID(id uint64) {
	m.deployment_package_fk = &id
}

// ClearDeploymentPackageFk clears the "deployment_package_fk" edge to the DeploymentPackage entity.
func (m *NamespaceMutation) ClearDeploymentPackageFk() {
	m.cleareddeployment_package_fk = true
}

// DeploymentPackageFkCleared reports if the "deployment_package_fk" edge to the DeploymentPackage entity was cleared.
func (m *NamespaceMutation) DeploymentPackageFkCleared() bool {
	return m.cleareddeployment_package_fk
}

// DeploymentPackageFkID returns the "deployment_package_fk" edge ID in the mutation.
func (m *NamespaceMutation) DeploymentPackageFkID() (id uint64, exists bool) {
	if m.deployment_package_fk != nil {
		return *m.deployment_package_fk, true
	}
	return
}

// DeploymentPackageFkIDs returns the "deployment_package_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentPackageFkID instead. It exists only for internal usage by the builders.
func (m *NamespaceMutation) DeploymentPackageFkIDs() (ids []uint64) {
	if id := m.deployment_package_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentPackageFk resets all changes to the "deployment_package_fk" edge.
func (m *NamespaceMutation) ResetDeploymentPackageFk() {
	m.deployment_package_fk = nil
	m.cleareddeployment_package_fk = false
}

// AddAdornmentIDs adds the "adornments" edge to the NamespaceAdornment entity by ids.
func (m *NamespaceMutation) AddAdornmentIDs(ids ...uint64) {
	if m.adornments == nil {
		m.adornments = make(map[uint64]struct{})
	}
	for i := range ids {
		m.adornments[ids[i]] = struct{}{}
	}
}

// ClearAdornments clears the "adornments" edge to the NamespaceAdornment entity.
func (m *NamespaceMutation) ClearAdornments() {
	m.clearedadornments = true
}

// AdornmentsCleared reports if the "adornments" edge to the NamespaceAdornment entity was cleared.
func (m *NamespaceMutation) AdornmentsCleared() bool {
	return m.clearedadornments
}

// RemoveAdornmentIDs removes the "adornments" edge to the NamespaceAdornment entity by IDs.
func (m *NamespaceMutation) RemoveAdornmentIDs(ids ...uint64) {
	if m.removedadornments == nil {
		m.removedadornments = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.adornments, ids[i])
		m.removedadornments[ids[i]] = struct{}{}
	}
}

// RemovedAdornments returns the removed IDs of the "adornments" edge to the NamespaceAdornment entity.
func (m *NamespaceMutation) RemovedAdornmentsIDs() (ids []uint64) {
	for id := range m.removedadornments {
		ids = append(ids, id)
	}
	return
}

// AdornmentsIDs returns the "adornments" edge IDs in the mutation.
func (m *NamespaceMutation) AdornmentsIDs() (ids []uint64) {
	for id := range m.adornments {
		ids = append(ids, id)
	}
	return
}

// ResetAdornments resets all changes to the "adornments" edge.
func (m *NamespaceMutation) ResetAdornments() {
	m.adornments = nil
	m.clearedadornments = false
	m.removedadornments = nil
}

// Where appends a list predicates to the NamespaceMutation builder.
func (m *NamespaceMutation) Where(ps ...predicate.Namespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Namespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, namespace.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.deployment_package_fk != nil {
		edges = append(edges, namespace.EdgeDeploymentPackageFk)
	}
	if m.adornments != nil {
		edges = append(edges, namespace.EdgeAdornments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeDeploymentPackageFk:
		if id := m.deployment_package_fk; id != nil {
			return []ent.Value{*id}
		}
	case namespace.EdgeAdornments:
		ids := make([]ent.Value, 0, len(m.adornments))
		for id := range m.adornments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedadornments != nil {
		edges = append(edges, namespace.EdgeAdornments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeAdornments:
		ids := make([]ent.Value, 0, len(m.removedadornments))
		for id := range m.removedadornments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeployment_package_fk {
		edges = append(edges, namespace.EdgeDeploymentPackageFk)
	}
	if m.clearedadornments {
		edges = append(edges, namespace.EdgeAdornments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeDeploymentPackageFk:
		return m.cleareddeployment_package_fk
	case namespace.EdgeAdornments:
		return m.clearedadornments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	case namespace.EdgeDeploymentPackageFk:
		m.ClearDeploymentPackageFk()
		return nil
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeDeploymentPackageFk:
		m.ResetDeploymentPackageFk()
		return nil
	case namespace.EdgeAdornments:
		m.ResetAdornments()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// NamespaceAdornmentMutation represents an operation that mutates the NamespaceAdornment nodes in the graph.
type NamespaceAdornmentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	_type               *string
	key                 *string
	value               *string
	clearedFields       map[string]struct{}
	namespace_fk        *uint64
	clearednamespace_fk bool
	done                bool
	oldValue            func(context.Context) (*NamespaceAdornment, error)
	predicates          []predicate.NamespaceAdornment
}

var _ ent.Mutation = (*NamespaceAdornmentMutation)(nil)

// namespaceadornmentOption allows management of the mutation configuration using functional options.
type namespaceadornmentOption func(*NamespaceAdornmentMutation)

// newNamespaceAdornmentMutation creates new mutation for the NamespaceAdornment entity.
func newNamespaceAdornmentMutation(c config, op Op, opts ...namespaceadornmentOption) *NamespaceAdornmentMutation {
	m := &NamespaceAdornmentMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespaceAdornment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceAdornmentID sets the ID field of the mutation.
func withNamespaceAdornmentID(id uint64) namespaceadornmentOption {
	return func(m *NamespaceAdornmentMutation) {
		var (
			err   error
			once  sync.Once
			value *NamespaceAdornment
		)
		m.oldValue = func(ctx context.Context) (*NamespaceAdornment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NamespaceAdornment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespaceAdornment sets the old NamespaceAdornment of the mutation.
func withNamespaceAdornment(node *NamespaceAdornment) namespaceadornmentOption {
	return func(m *NamespaceAdornmentMutation) {
		m.oldValue = func(context.Context) (*NamespaceAdornment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceAdornmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceAdornmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceAdornmentMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceAdornmentMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NamespaceAdornment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *NamespaceAdornmentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NamespaceAdornmentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NamespaceAdornment entity.
// If the NamespaceAdornment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceAdornmentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NamespaceAdornmentMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *NamespaceAdornmentMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *NamespaceAdornmentMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the NamespaceAdornment entity.
// If the NamespaceAdornment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceAdornmentMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *NamespaceAdornmentMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *NamespaceAdornmentMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *NamespaceAdornmentMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the NamespaceAdornment entity.
// If the NamespaceAdornment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceAdornmentMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *NamespaceAdornmentMutation) ClearValue() {
	m.value = nil
	m.clearedFields[namespaceadornment.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *NamespaceAdornmentMutation) ValueCleared() bool {
	_, ok := m.clearedFields[namespaceadornment.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *NamespaceAdornmentMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, namespaceadornment.FieldValue)
}

// SetNamespaceFkID sets the "namespace_fk" edge to the Namespace entity by id.
func (m *NamespaceAdornmentMutation) SetNamespaceFkID(id uint64) {
	m.namespace_fk = &id
}

// ClearNamespaceFk clears the "namespace_fk" edge to the Namespace entity.
func (m *NamespaceAdornmentMutation) ClearNamespaceFk() {
	m.clearednamespace_fk = true
}

// NamespaceFkCleared reports if the "namespace_fk" edge to the Namespace entity was cleared.
func (m *NamespaceAdornmentMutation) NamespaceFkCleared() bool {
	return m.clearednamespace_fk
}

// NamespaceFkID returns the "namespace_fk" edge ID in the mutation.
func (m *NamespaceAdornmentMutation) NamespaceFkID() (id uint64, exists bool) {
	if m.namespace_fk != nil {
		return *m.namespace_fk, true
	}
	return
}

// NamespaceFkIDs returns the "namespace_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceFkID instead. It exists only for internal usage by the builders.
func (m *NamespaceAdornmentMutation) NamespaceFkIDs() (ids []uint64) {
	if id := m.namespace_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespaceFk resets all changes to the "namespace_fk" edge.
func (m *NamespaceAdornmentMutation) ResetNamespaceFk() {
	m.namespace_fk = nil
	m.clearednamespace_fk = false
}

// Where appends a list predicates to the NamespaceAdornmentMutation builder.
func (m *NamespaceAdornmentMutation) Where(ps ...predicate.NamespaceAdornment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NamespaceAdornmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NamespaceAdornmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NamespaceAdornment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NamespaceAdornmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NamespaceAdornmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NamespaceAdornment).
func (m *NamespaceAdornmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceAdornmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._type != nil {
		fields = append(fields, namespaceadornment.FieldType)
	}
	if m.key != nil {
		fields = append(fields, namespaceadornment.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, namespaceadornment.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceAdornmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespaceadornment.FieldType:
		return m.GetType()
	case namespaceadornment.FieldKey:
		return m.Key()
	case namespaceadornment.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceAdornmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespaceadornment.FieldType:
		return m.OldType(ctx)
	case namespaceadornment.FieldKey:
		return m.OldKey(ctx)
	case namespaceadornment.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown NamespaceAdornment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceAdornmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespaceadornment.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case namespaceadornment.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case namespaceadornment.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown NamespaceAdornment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceAdornmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceAdornmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceAdornmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NamespaceAdornment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceAdornmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(namespaceadornment.FieldValue) {
		fields = append(fields, namespaceadornment.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceAdornmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceAdornmentMutation) ClearField(name string) error {
	switch name {
	case namespaceadornment.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown NamespaceAdornment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceAdornmentMutation) ResetField(name string) error {
	switch name {
	case namespaceadornment.FieldType:
		m.ResetType()
		return nil
	case namespaceadornment.FieldKey:
		m.ResetKey()
		return nil
	case namespaceadornment.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown NamespaceAdornment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceAdornmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace_fk != nil {
		edges = append(edges, namespaceadornment.EdgeNamespaceFk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceAdornmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespaceadornment.EdgeNamespaceFk:
		if id := m.namespace_fk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceAdornmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceAdornmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceAdornmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace_fk {
		edges = append(edges, namespaceadornment.EdgeNamespaceFk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceAdornmentMutation) EdgeCleared(name string) bool {
	switch name {
	case namespaceadornment.EdgeNamespaceFk:
		return m.clearednamespace_fk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceAdornmentMutation) ClearEdge(name string) error {
	switch name {
	case namespaceadornment.EdgeNamespaceFk:
		m.ClearNamespaceFk()
		return nil
	}
	return fmt.Errorf("unknown NamespaceAdornment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceAdornmentMutation) ResetEdge(name string) error {
	switch name {
	case namespaceadornment.EdgeNamespaceFk:
		m.ResetNamespaceFk()
		return nil
	}
	return fmt.Errorf("unknown NamespaceAdornment edge %s", name)
}

// ParameterTemplateMutation represents an operation that mutates the ParameterTemplate nodes in the graph.
type ParameterTemplateMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint64
	name                   *string
	display_name           *string
	display_name_lc        *string
	_default               *string
	_type                  *string
	validator              *string
	suggested_values       *[]string
	appendsuggested_values []string
	mandatory              *bool
	secret                 *bool
	clearedFields          map[string]struct{}
	profile_fk             *uint64
	clearedprofile_fk      bool
	profiles               map[uint64]struct{}
	removedprofiles        map[uint64]struct{}
	clearedprofiles        bool
	done                   bool
	oldValue               func(context.Context) (*ParameterTemplate, error)
	predicates             []predicate.ParameterTemplate
}

var _ ent.Mutation = (*ParameterTemplateMutation)(nil)

// parametertemplateOption allows management of the mutation configuration using functional options.
type parametertemplateOption func(*ParameterTemplateMutation)

// newParameterTemplateMutation creates new mutation for the ParameterTemplate entity.
func newParameterTemplateMutation(c config, op Op, opts ...parametertemplateOption) *ParameterTemplateMutation {
	m := &ParameterTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeParameterTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParameterTemplateID sets the ID field of the mutation.
func withParameterTemplateID(id uint64) parametertemplateOption {
	return func(m *ParameterTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *ParameterTemplate
		)
		m.oldValue = func(ctx context.Context) (*ParameterTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParameterTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParameterTemplate sets the old ParameterTemplate of the mutation.
func withParameterTemplate(node *ParameterTemplate) parametertemplateOption {
	return func(m *ParameterTemplateMutation) {
		m.oldValue = func(context.Context) (*ParameterTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParameterTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParameterTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParameterTemplateMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParameterTemplateMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParameterTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ParameterTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ParameterTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ParameterTemplateMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ParameterTemplateMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ParameterTemplateMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ParameterTemplateMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[parametertemplate.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ParameterTemplateMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ParameterTemplateMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, parametertemplate.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *ParameterTemplateMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *ParameterTemplateMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *ParameterTemplateMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[parametertemplate.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *ParameterTemplateMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *ParameterTemplateMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, parametertemplate.FieldDisplayNameLc)
}

// SetDefault sets the "default" field.
func (m *ParameterTemplateMutation) SetDefault(s string) {
	m._default = &s
}

// Default returns the value of the "default" field in the mutation.
func (m *ParameterTemplateMutation) Default() (r string, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldDefault(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ClearDefault clears the value of the "default" field.
func (m *ParameterTemplateMutation) ClearDefault() {
	m._default = nil
	m.clearedFields[parametertemplate.FieldDefault] = struct{}{}
}

// DefaultCleared returns if the "default" field was cleared in this mutation.
func (m *ParameterTemplateMutation) DefaultCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldDefault]
	return ok
}

// ResetDefault resets all changes to the "default" field.
func (m *ParameterTemplateMutation) ResetDefault() {
	m._default = nil
	delete(m.clearedFields, parametertemplate.FieldDefault)
}

// SetType sets the "type" field.
func (m *ParameterTemplateMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ParameterTemplateMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ParameterTemplateMutation) ClearType() {
	m._type = nil
	m.clearedFields[parametertemplate.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ParameterTemplateMutation) TypeCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ParameterTemplateMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, parametertemplate.FieldType)
}

// SetValidator sets the "validator" field.
func (m *ParameterTemplateMutation) SetValidator(s string) {
	m.validator = &s
}

// Validator returns the value of the "validator" field in the mutation.
func (m *ParameterTemplateMutation) Validator() (r string, exists bool) {
	v := m.validator
	if v == nil {
		return
	}
	return *v, true
}

// OldValidator returns the old "validator" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldValidator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidator: %w", err)
	}
	return oldValue.Validator, nil
}

// ClearValidator clears the value of the "validator" field.
func (m *ParameterTemplateMutation) ClearValidator() {
	m.validator = nil
	m.clearedFields[parametertemplate.FieldValidator] = struct{}{}
}

// ValidatorCleared returns if the "validator" field was cleared in this mutation.
func (m *ParameterTemplateMutation) ValidatorCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldValidator]
	return ok
}

// ResetValidator resets all changes to the "validator" field.
func (m *ParameterTemplateMutation) ResetValidator() {
	m.validator = nil
	delete(m.clearedFields, parametertemplate.FieldValidator)
}

// SetSuggestedValues sets the "suggested_values" field.
func (m *ParameterTemplateMutation) SetSuggestedValues(s []string) {
	m.suggested_values = &s
	m.appendsuggested_values = nil
}

// SuggestedValues returns the value of the "suggested_values" field in the mutation.
func (m *ParameterTemplateMutation) SuggestedValues() (r []string, exists bool) {
	v := m.suggested_values
	if v == nil {
		return
	}
	return *v, true
}

// OldSuggestedValues returns the old "suggested_values" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldSuggestedValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuggestedValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuggestedValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuggestedValues: %w", err)
	}
	return oldValue.SuggestedValues, nil
}

// AppendSuggestedValues adds s to the "suggested_values" field.
func (m *ParameterTemplateMutation) AppendSuggestedValues(s []string) {
	m.appendsuggested_values = append(m.appendsuggested_values, s...)
}

// AppendedSuggestedValues returns the list of values that were appended to the "suggested_values" field in this mutation.
func (m *ParameterTemplateMutation) AppendedSuggestedValues() ([]string, bool) {
	if len(m.appendsuggested_values) == 0 {
		return nil, false
	}
	return m.appendsuggested_values, true
}

// ClearSuggestedValues clears the value of the "suggested_values" field.
func (m *ParameterTemplateMutation) ClearSuggestedValues() {
	m.suggested_values = nil
	m.appendsuggested_values = nil
	m.clearedFields[parametertemplate.FieldSuggestedValues] = struct{}{}
}

// SuggestedValuesCleared returns if the "suggested_values" field was cleared in this mutation.
func (m *ParameterTemplateMutation) SuggestedValuesCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldSuggestedValues]
	return ok
}

// ResetSuggestedValues resets all changes to the "suggested_values" field.
func (m *ParameterTemplateMutation) ResetSuggestedValues() {
	m.suggested_values = nil
	m.appendsuggested_values = nil
	delete(m.clearedFields, parametertemplate.FieldSuggestedValues)
}

// SetMandatory sets the "mandatory" field.
func (m *ParameterTemplateMutation) SetMandatory(b bool) {
	m.mandatory = &b
}

// Mandatory returns the value of the "mandatory" field in the mutation.
func (m *ParameterTemplateMutation) Mandatory() (r bool, exists bool) {
	v := m.mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldMandatory returns the old "mandatory" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMandatory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMandatory: %w", err)
	}
	return oldValue.Mandatory, nil
}

// ClearMandatory clears the value of the "mandatory" field.
func (m *ParameterTemplateMutation) ClearMandatory() {
	m.mandatory = nil
	m.clearedFields[parametertemplate.FieldMandatory] = struct{}{}
}

// MandatoryCleared returns if the "mandatory" field was cleared in this mutation.
func (m *ParameterTemplateMutation) MandatoryCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldMandatory]
	return ok
}

// ResetMandatory resets all changes to the "mandatory" field.
func (m *ParameterTemplateMutation) ResetMandatory() {
	m.mandatory = nil
	delete(m.clearedFields, parametertemplate.FieldMandatory)
}

// SetSecret sets the "secret" field.
func (m *ParameterTemplateMutation) SetSecret(b bool) {
	m.secret = &b
}

// Secret returns the value of the "secret" field in the mutation.
func (m *ParameterTemplateMutation) Secret() (r bool, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the ParameterTemplate entity.
// If the ParameterTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParameterTemplateMutation) OldSecret(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *ParameterTemplateMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[parametertemplate.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *ParameterTemplateMutation) SecretCleared() bool {
	_, ok := m.clearedFields[parametertemplate.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *ParameterTemplateMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, parametertemplate.FieldSecret)
}

// SetProfileFkID sets the "profile_fk" edge to the Profile entity by id.
func (m *ParameterTemplateMutation) SetProfileFkID(id uint64) {
	m.profile_fk = &id
}

// ClearProfileFk clears the "profile_fk" edge to the Profile entity.
func (m *ParameterTemplateMutation) ClearProfileFk() {
	m.clearedprofile_fk = true
}

// ProfileFkCleared reports if the "profile_fk" edge to the Profile entity was cleared.
func (m *ParameterTemplateMutation) ProfileFkCleared() bool {
	return m.clearedprofile_fk
}

// ProfileFkID returns the "profile_fk" edge ID in the mutation.
func (m *ParameterTemplateMutation) ProfileFkID() (id uint64, exists bool) {
	if m.profile_fk != nil {
		return *m.profile_fk, true
	}
	return
}

// ProfileFkIDs returns the "profile_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileFkID instead. It exists only for internal usage by the builders.
func (m *ParameterTemplateMutation) ProfileFkIDs() (ids []uint64) {
	if id := m.profile_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfileFk resets all changes to the "profile_fk" edge.
func (m *ParameterTemplateMutation) ResetProfileFk() {
	m.profile_fk = nil
	m.clearedprofile_fk = false
}

// AddProfileIDs adds the "profiles" edge to the Profile entity by ids.
func (m *ParameterTemplateMutation) AddProfileIDs(ids ...uint64) {
	if m.profiles == nil {
		m.profiles = make(map[uint64]struct{})
	}
	for i := range ids {
		m.profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "profiles" edge to the Profile entity.
func (m *ParameterTemplateMutation) ClearProfiles() {
	m.clearedprofiles = true
}

// ProfilesCleared reports if the "profiles" edge to the Profile entity was cleared.
func (m *ParameterTemplateMutation) ProfilesCleared() bool {
	return m.clearedprofiles
}

// RemoveProfileIDs removes the "profiles" edge to the Profile entity by IDs.
func (m *ParameterTemplateMutation) RemoveProfileIDs(ids ...uint64) {
	if m.removedprofiles == nil {
		m.removedprofiles = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.profiles, ids[i])
		m.removedprofiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "profiles" edge to the Profile entity.
func (m *ParameterTemplateMutation) RemovedProfilesIDs() (ids []uint64) {
	for id := range m.removedprofiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "profiles" edge IDs in the mutation.
func (m *ParameterTemplateMutation) ProfilesIDs() (ids []uint64) {
	for id := range m.profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "profiles" edge.
func (m *ParameterTemplateMutation) ResetProfiles() {
	m.profiles = nil
	m.clearedprofiles = false
	m.removedprofiles = nil
}

// Where appends a list predicates to the ParameterTemplateMutation builder.
func (m *ParameterTemplateMutation) Where(ps ...predicate.ParameterTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParameterTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParameterTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ParameterTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParameterTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParameterTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ParameterTemplate).
func (m *ParameterTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParameterTemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, parametertemplate.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, parametertemplate.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, parametertemplate.FieldDisplayNameLc)
	}
	if m._default != nil {
		fields = append(fields, parametertemplate.FieldDefault)
	}
	if m._type != nil {
		fields = append(fields, parametertemplate.FieldType)
	}
	if m.validator != nil {
		fields = append(fields, parametertemplate.FieldValidator)
	}
	if m.suggested_values != nil {
		fields = append(fields, parametertemplate.FieldSuggestedValues)
	}
	if m.mandatory != nil {
		fields = append(fields, parametertemplate.FieldMandatory)
	}
	if m.secret != nil {
		fields = append(fields, parametertemplate.FieldSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParameterTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parametertemplate.FieldName:
		return m.Name()
	case parametertemplate.FieldDisplayName:
		return m.DisplayName()
	case parametertemplate.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case parametertemplate.FieldDefault:
		return m.Default()
	case parametertemplate.FieldType:
		return m.GetType()
	case parametertemplate.FieldValidator:
		return m.Validator()
	case parametertemplate.FieldSuggestedValues:
		return m.SuggestedValues()
	case parametertemplate.FieldMandatory:
		return m.Mandatory()
	case parametertemplate.FieldSecret:
		return m.Secret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParameterTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parametertemplate.FieldName:
		return m.OldName(ctx)
	case parametertemplate.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case parametertemplate.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case parametertemplate.FieldDefault:
		return m.OldDefault(ctx)
	case parametertemplate.FieldType:
		return m.OldType(ctx)
	case parametertemplate.FieldValidator:
		return m.OldValidator(ctx)
	case parametertemplate.FieldSuggestedValues:
		return m.OldSuggestedValues(ctx)
	case parametertemplate.FieldMandatory:
		return m.OldMandatory(ctx)
	case parametertemplate.FieldSecret:
		return m.OldSecret(ctx)
	}
	return nil, fmt.Errorf("unknown ParameterTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParameterTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parametertemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case parametertemplate.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case parametertemplate.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case parametertemplate.FieldDefault:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case parametertemplate.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case parametertemplate.FieldValidator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidator(v)
		return nil
	case parametertemplate.FieldSuggestedValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuggestedValues(v)
		return nil
	case parametertemplate.FieldMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMandatory(v)
		return nil
	case parametertemplate.FieldSecret:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	}
	return fmt.Errorf("unknown ParameterTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParameterTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParameterTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParameterTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParameterTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParameterTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(parametertemplate.FieldDisplayName) {
		fields = append(fields, parametertemplate.FieldDisplayName)
	}
	if m.FieldCleared(parametertemplate.FieldDisplayNameLc) {
		fields = append(fields, parametertemplate.FieldDisplayNameLc)
	}
	if m.FieldCleared(parametertemplate.FieldDefault) {
		fields = append(fields, parametertemplate.FieldDefault)
	}
	if m.FieldCleared(parametertemplate.FieldType) {
		fields = append(fields, parametertemplate.FieldType)
	}
	if m.FieldCleared(parametertemplate.FieldValidator) {
		fields = append(fields, parametertemplate.FieldValidator)
	}
	if m.FieldCleared(parametertemplate.FieldSuggestedValues) {
		fields = append(fields, parametertemplate.FieldSuggestedValues)
	}
	if m.FieldCleared(parametertemplate.FieldMandatory) {
		fields = append(fields, parametertemplate.FieldMandatory)
	}
	if m.FieldCleared(parametertemplate.FieldSecret) {
		fields = append(fields, parametertemplate.FieldSecret)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParameterTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParameterTemplateMutation) ClearField(name string) error {
	switch name {
	case parametertemplate.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case parametertemplate.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case parametertemplate.FieldDefault:
		m.ClearDefault()
		return nil
	case parametertemplate.FieldType:
		m.ClearType()
		return nil
	case parametertemplate.FieldValidator:
		m.ClearValidator()
		return nil
	case parametertemplate.FieldSuggestedValues:
		m.ClearSuggestedValues()
		return nil
	case parametertemplate.FieldMandatory:
		m.ClearMandatory()
		return nil
	case parametertemplate.FieldSecret:
		m.ClearSecret()
		return nil
	}
	return fmt.Errorf("unknown ParameterTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParameterTemplateMutation) ResetField(name string) error {
	switch name {
	case parametertemplate.FieldName:
		m.ResetName()
		return nil
	case parametertemplate.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case parametertemplate.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case parametertemplate.FieldDefault:
		m.ResetDefault()
		return nil
	case parametertemplate.FieldType:
		m.ResetType()
		return nil
	case parametertemplate.FieldValidator:
		m.ResetValidator()
		return nil
	case parametertemplate.FieldSuggestedValues:
		m.ResetSuggestedValues()
		return nil
	case parametertemplate.FieldMandatory:
		m.ResetMandatory()
		return nil
	case parametertemplate.FieldSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown ParameterTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParameterTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profile_fk != nil {
		edges = append(edges, parametertemplate.EdgeProfileFk)
	}
	if m.profiles != nil {
		edges = append(edges, parametertemplate.EdgeProfiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParameterTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parametertemplate.EdgeProfileFk:
		if id := m.profile_fk; id != nil {
			return []ent.Value{*id}
		}
	case parametertemplate.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.profiles))
		for id := range m.profiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParameterTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprofiles != nil {
		edges = append(edges, parametertemplate.EdgeProfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParameterTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case parametertemplate.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removedprofiles))
		for id := range m.removedprofiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParameterTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofile_fk {
		edges = append(edges, parametertemplate.EdgeProfileFk)
	}
	if m.clearedprofiles {
		edges = append(edges, parametertemplate.EdgeProfiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParameterTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case parametertemplate.EdgeProfileFk:
		return m.clearedprofile_fk
	case parametertemplate.EdgeProfiles:
		return m.clearedprofiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParameterTemplateMutation) ClearEdge(name string) error {
	switch name {
	case parametertemplate.EdgeProfileFk:
		m.ClearProfileFk()
		return nil
	}
	return fmt.Errorf("unknown ParameterTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParameterTemplateMutation) ResetEdge(name string) error {
	switch name {
	case parametertemplate.EdgeProfileFk:
		m.ResetProfileFk()
		return nil
	case parametertemplate.EdgeProfiles:
		m.ResetProfiles()
		return nil
	}
	return fmt.Errorf("unknown ParameterTemplate edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uint64
	name                           *string
	display_name                   *string
	display_name_lc                *string
	description                    *string
	create_time                    *time.Time
	update_time                    *time.Time
	chart_values                   *string
	clearedFields                  map[string]struct{}
	application_fk                 *uint64
	clearedapplication_fk          bool
	deployment_profiles            map[uint64]struct{}
	removeddeployment_profiles     map[uint64]struct{}
	cleareddeployment_profiles     bool
	parameter_templates            map[uint64]struct{}
	removedparameter_templates     map[uint64]struct{}
	clearedparameter_templates     bool
	deployment_requirements        map[uint64]struct{}
	removeddeployment_requirements map[uint64]struct{}
	cleareddeployment_requirements bool
	done                           bool
	oldValue                       func(context.Context) (*Profile, error)
	predicates                     []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id uint64) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProfileMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ProfileMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProfileMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProfileMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[profile.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProfileMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProfileMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, profile.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *ProfileMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *ProfileMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *ProfileMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[profile.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *ProfileMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[profile.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *ProfileMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, profile.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *ProfileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProfileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProfileMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[profile.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProfileMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[profile.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProfileMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, profile.FieldDescription)
}

// SetCreateTime sets the "create_time" field.
func (m *ProfileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProfileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProfileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProfileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProfileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProfileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetChartValues sets the "chart_values" field.
func (m *ProfileMutation) SetChartValues(s string) {
	m.chart_values = &s
}

// ChartValues returns the value of the "chart_values" field in the mutation.
func (m *ProfileMutation) ChartValues() (r string, exists bool) {
	v := m.chart_values
	if v == nil {
		return
	}
	return *v, true
}

// OldChartValues returns the old "chart_values" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldChartValues(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChartValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChartValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChartValues: %w", err)
	}
	return oldValue.ChartValues, nil
}

// ResetChartValues resets all changes to the "chart_values" field.
func (m *ProfileMutation) ResetChartValues() {
	m.chart_values = nil
}

// SetApplicationFkID sets the "application_fk" edge to the Application entity by id.
func (m *ProfileMutation) SetApplicationFkID(id uint64) {
	m.application_fk = &id
}

// ClearApplicationFk clears the "application_fk" edge to the Application entity.
func (m *ProfileMutation) ClearApplicationFk() {
	m.clearedapplication_fk = true
}

// ApplicationFkCleared reports if the "application_fk" edge to the Application entity was cleared.
func (m *ProfileMutation) ApplicationFkCleared() bool {
	return m.clearedapplication_fk
}

// ApplicationFkID returns the "application_fk" edge ID in the mutation.
func (m *ProfileMutation) ApplicationFkID() (id uint64, exists bool) {
	if m.application_fk != nil {
		return *m.application_fk, true
	}
	return
}

// ApplicationFkIDs returns the "application_fk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationFkID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) ApplicationFkIDs() (ids []uint64) {
	if id := m.application_fk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicationFk resets all changes to the "application_fk" edge.
func (m *ProfileMutation) ResetApplicationFk() {
	m.application_fk = nil
	m.clearedapplication_fk = false
}

// AddDeploymentProfileIDs adds the "deployment_profiles" edge to the DeploymentProfile entity by ids.
func (m *ProfileMutation) AddDeploymentProfileIDs(ids ...uint64) {
	if m.deployment_profiles == nil {
		m.deployment_profiles = make(map[uint64]struct{})
	}
	for i := range ids {
		m.deployment_profiles[ids[i]] = struct{}{}
	}
}

// ClearDeploymentProfiles clears the "deployment_profiles" edge to the DeploymentProfile entity.
func (m *ProfileMutation) ClearDeploymentProfiles() {
	m.cleareddeployment_profiles = true
}

// DeploymentProfilesCleared reports if the "deployment_profiles" edge to the DeploymentProfile entity was cleared.
func (m *ProfileMutation) DeploymentProfilesCleared() bool {
	return m.cleareddeployment_profiles
}

// RemoveDeploymentProfileIDs removes the "deployment_profiles" edge to the DeploymentProfile entity by IDs.
func (m *ProfileMutation) RemoveDeploymentProfileIDs(ids ...uint64) {
	if m.removeddeployment_profiles == nil {
		m.removeddeployment_profiles = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.deployment_profiles, ids[i])
		m.removeddeployment_profiles[ids[i]] = struct{}{}
	}
}

// RemovedDeploymentProfiles returns the removed IDs of the "deployment_profiles" edge to the DeploymentProfile entity.
func (m *ProfileMutation) RemovedDeploymentProfilesIDs() (ids []uint64) {
	for id := range m.removeddeployment_profiles {
		ids = append(ids, id)
	}
	return
}

// DeploymentProfilesIDs returns the "deployment_profiles" edge IDs in the mutation.
func (m *ProfileMutation) DeploymentProfilesIDs() (ids []uint64) {
	for id := range m.deployment_profiles {
		ids = append(ids, id)
	}
	return
}

// ResetDeploymentProfiles resets all changes to the "deployment_profiles" edge.
func (m *ProfileMutation) ResetDeploymentProfiles() {
	m.deployment_profiles = nil
	m.cleareddeployment_profiles = false
	m.removeddeployment_profiles = nil
}

// AddParameterTemplateIDs adds the "parameter_templates" edge to the ParameterTemplate entity by ids.
func (m *ProfileMutation) AddParameterTemplateIDs(ids ...uint64) {
	if m.parameter_templates == nil {
		m.parameter_templates = make(map[uint64]struct{})
	}
	for i := range ids {
		m.parameter_templates[ids[i]] = struct{}{}
	}
}

// ClearParameterTemplates clears the "parameter_templates" edge to the ParameterTemplate entity.
func (m *ProfileMutation) ClearParameterTemplates() {
	m.clearedparameter_templates = true
}

// ParameterTemplatesCleared reports if the "parameter_templates" edge to the ParameterTemplate entity was cleared.
func (m *ProfileMutation) ParameterTemplatesCleared() bool {
	return m.clearedparameter_templates
}

// RemoveParameterTemplateIDs removes the "parameter_templates" edge to the ParameterTemplate entity by IDs.
func (m *ProfileMutation) RemoveParameterTemplateIDs(ids ...uint64) {
	if m.removedparameter_templates == nil {
		m.removedparameter_templates = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.parameter_templates, ids[i])
		m.removedparameter_templates[ids[i]] = struct{}{}
	}
}

// RemovedParameterTemplates returns the removed IDs of the "parameter_templates" edge to the ParameterTemplate entity.
func (m *ProfileMutation) RemovedParameterTemplatesIDs() (ids []uint64) {
	for id := range m.removedparameter_templates {
		ids = append(ids, id)
	}
	return
}

// ParameterTemplatesIDs returns the "parameter_templates" edge IDs in the mutation.
func (m *ProfileMutation) ParameterTemplatesIDs() (ids []uint64) {
	for id := range m.parameter_templates {
		ids = append(ids, id)
	}
	return
}

// ResetParameterTemplates resets all changes to the "parameter_templates" edge.
func (m *ProfileMutation) ResetParameterTemplates() {
	m.parameter_templates = nil
	m.clearedparameter_templates = false
	m.removedparameter_templates = nil
}

// AddDeploymentRequirementIDs adds the "deployment_requirements" edge to the DeploymentRequirement entity by ids.
func (m *ProfileMutation) AddDeploymentRequirementIDs(ids ...uint64) {
	if m.deployment_requirements == nil {
		m.deployment_requirements = make(map[uint64]struct{})
	}
	for i := range ids {
		m.deployment_requirements[ids[i]] = struct{}{}
	}
}

// ClearDeploymentRequirements clears the "deployment_requirements" edge to the DeploymentRequirement entity.
func (m *ProfileMutation) ClearDeploymentRequirements() {
	m.cleareddeployment_requirements = true
}

// DeploymentRequirementsCleared reports if the "deployment_requirements" edge to the DeploymentRequirement entity was cleared.
func (m *ProfileMutation) DeploymentRequirementsCleared() bool {
	return m.cleareddeployment_requirements
}

// RemoveDeploymentRequirementIDs removes the "deployment_requirements" edge to the DeploymentRequirement entity by IDs.
func (m *ProfileMutation) RemoveDeploymentRequirementIDs(ids ...uint64) {
	if m.removeddeployment_requirements == nil {
		m.removeddeployment_requirements = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.deployment_requirements, ids[i])
		m.removeddeployment_requirements[ids[i]] = struct{}{}
	}
}

// RemovedDeploymentRequirements returns the removed IDs of the "deployment_requirements" edge to the DeploymentRequirement entity.
func (m *ProfileMutation) RemovedDeploymentRequirementsIDs() (ids []uint64) {
	for id := range m.removeddeployment_requirements {
		ids = append(ids, id)
	}
	return
}

// DeploymentRequirementsIDs returns the "deployment_requirements" edge IDs in the mutation.
func (m *ProfileMutation) DeploymentRequirementsIDs() (ids []uint64) {
	for id := range m.deployment_requirements {
		ids = append(ids, id)
	}
	return
}

// ResetDeploymentRequirements resets all changes to the "deployment_requirements" edge.
func (m *ProfileMutation) ResetDeploymentRequirements() {
	m.deployment_requirements = nil
	m.cleareddeployment_requirements = false
	m.removeddeployment_requirements = nil
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, profile.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, profile.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, profile.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, profile.FieldDescription)
	}
	if m.create_time != nil {
		fields = append(fields, profile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, profile.FieldUpdateTime)
	}
	if m.chart_values != nil {
		fields = append(fields, profile.FieldChartValues)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldName:
		return m.Name()
	case profile.FieldDisplayName:
		return m.DisplayName()
	case profile.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case profile.FieldDescription:
		return m.Description()
	case profile.FieldCreateTime:
		return m.CreateTime()
	case profile.FieldUpdateTime:
		return m.UpdateTime()
	case profile.FieldChartValues:
		return m.ChartValues()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldName:
		return m.OldName(ctx)
	case profile.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case profile.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case profile.FieldDescription:
		return m.OldDescription(ctx)
	case profile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case profile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case profile.FieldChartValues:
		return m.OldChartValues(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case profile.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case profile.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case profile.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case profile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case profile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case profile.FieldChartValues:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChartValues(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldDisplayName) {
		fields = append(fields, profile.FieldDisplayName)
	}
	if m.FieldCleared(profile.FieldDisplayNameLc) {
		fields = append(fields, profile.FieldDisplayNameLc)
	}
	if m.FieldCleared(profile.FieldDescription) {
		fields = append(fields, profile.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case profile.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case profile.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldName:
		m.ResetName()
		return nil
	case profile.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case profile.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case profile.FieldDescription:
		m.ResetDescription()
		return nil
	case profile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case profile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case profile.FieldChartValues:
		m.ResetChartValues()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.application_fk != nil {
		edges = append(edges, profile.EdgeApplicationFk)
	}
	if m.deployment_profiles != nil {
		edges = append(edges, profile.EdgeDeploymentProfiles)
	}
	if m.parameter_templates != nil {
		edges = append(edges, profile.EdgeParameterTemplates)
	}
	if m.deployment_requirements != nil {
		edges = append(edges, profile.EdgeDeploymentRequirements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeApplicationFk:
		if id := m.application_fk; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeDeploymentProfiles:
		ids := make([]ent.Value, 0, len(m.deployment_profiles))
		for id := range m.deployment_profiles {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeParameterTemplates:
		ids := make([]ent.Value, 0, len(m.parameter_templates))
		for id := range m.parameter_templates {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeDeploymentRequirements:
		ids := make([]ent.Value, 0, len(m.deployment_requirements))
		for id := range m.deployment_requirements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddeployment_profiles != nil {
		edges = append(edges, profile.EdgeDeploymentProfiles)
	}
	if m.removedparameter_templates != nil {
		edges = append(edges, profile.EdgeParameterTemplates)
	}
	if m.removeddeployment_requirements != nil {
		edges = append(edges, profile.EdgeDeploymentRequirements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeDeploymentProfiles:
		ids := make([]ent.Value, 0, len(m.removeddeployment_profiles))
		for id := range m.removeddeployment_profiles {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeParameterTemplates:
		ids := make([]ent.Value, 0, len(m.removedparameter_templates))
		for id := range m.removedparameter_templates {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeDeploymentRequirements:
		ids := make([]ent.Value, 0, len(m.removeddeployment_requirements))
		for id := range m.removeddeployment_requirements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedapplication_fk {
		edges = append(edges, profile.EdgeApplicationFk)
	}
	if m.cleareddeployment_profiles {
		edges = append(edges, profile.EdgeDeploymentProfiles)
	}
	if m.clearedparameter_templates {
		edges = append(edges, profile.EdgeParameterTemplates)
	}
	if m.cleareddeployment_requirements {
		edges = append(edges, profile.EdgeDeploymentRequirements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeApplicationFk:
		return m.clearedapplication_fk
	case profile.EdgeDeploymentProfiles:
		return m.cleareddeployment_profiles
	case profile.EdgeParameterTemplates:
		return m.clearedparameter_templates
	case profile.EdgeDeploymentRequirements:
		return m.cleareddeployment_requirements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeApplicationFk:
		m.ClearApplicationFk()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeApplicationFk:
		m.ResetApplicationFk()
		return nil
	case profile.EdgeDeploymentProfiles:
		m.ResetDeploymentProfiles()
		return nil
	case profile.EdgeParameterTemplates:
		m.ResetParameterTemplates()
		return nil
	case profile.EdgeDeploymentRequirements:
		m.ResetDeploymentRequirements()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// RegistryMutation represents an operation that mutates the Registry nodes in the graph.
type RegistryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint64
	name                      *string
	display_name              *string
	display_name_lc           *string
	description               *string
	create_time               *time.Time
	update_time               *time.Time
	project_uuid              *string
	auth_token                *string
	_type                     *string
	api_type                  *string
	clearedFields             map[string]struct{}
	applications              map[uint64]struct{}
	removedapplications       map[uint64]struct{}
	clearedapplications       bool
	application_images        map[uint64]struct{}
	removedapplication_images map[uint64]struct{}
	clearedapplication_images bool
	done                      bool
	oldValue                  func(context.Context) (*Registry, error)
	predicates                []predicate.Registry
}

var _ ent.Mutation = (*RegistryMutation)(nil)

// registryOption allows management of the mutation configuration using functional options.
type registryOption func(*RegistryMutation)

// newRegistryMutation creates new mutation for the Registry entity.
func newRegistryMutation(c config, op Op, opts ...registryOption) *RegistryMutation {
	m := &RegistryMutation{
		config:        c,
		op:            op,
		typ:           TypeRegistry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegistryID sets the ID field of the mutation.
func withRegistryID(id uint64) registryOption {
	return func(m *RegistryMutation) {
		var (
			err   error
			once  sync.Once
			value *Registry
		)
		m.oldValue = func(ctx context.Context) (*Registry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Registry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegistry sets the old Registry of the mutation.
func withRegistry(node *Registry) registryOption {
	return func(m *RegistryMutation) {
		m.oldValue = func(context.Context) (*Registry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegistryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegistryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegistryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegistryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Registry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RegistryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RegistryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RegistryMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *RegistryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *RegistryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *RegistryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[registry.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *RegistryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[registry.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *RegistryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, registry.FieldDisplayName)
}

// SetDisplayNameLc sets the "display_name_lc" field.
func (m *RegistryMutation) SetDisplayNameLc(s string) {
	m.display_name_lc = &s
}

// DisplayNameLc returns the value of the "display_name_lc" field in the mutation.
func (m *RegistryMutation) DisplayNameLc() (r string, exists bool) {
	v := m.display_name_lc
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNameLc returns the old "display_name_lc" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldDisplayNameLc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNameLc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNameLc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNameLc: %w", err)
	}
	return oldValue.DisplayNameLc, nil
}

// ClearDisplayNameLc clears the value of the "display_name_lc" field.
func (m *RegistryMutation) ClearDisplayNameLc() {
	m.display_name_lc = nil
	m.clearedFields[registry.FieldDisplayNameLc] = struct{}{}
}

// DisplayNameLcCleared returns if the "display_name_lc" field was cleared in this mutation.
func (m *RegistryMutation) DisplayNameLcCleared() bool {
	_, ok := m.clearedFields[registry.FieldDisplayNameLc]
	return ok
}

// ResetDisplayNameLc resets all changes to the "display_name_lc" field.
func (m *RegistryMutation) ResetDisplayNameLc() {
	m.display_name_lc = nil
	delete(m.clearedFields, registry.FieldDisplayNameLc)
}

// SetDescription sets the "description" field.
func (m *RegistryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RegistryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RegistryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[registry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RegistryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[registry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RegistryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, registry.FieldDescription)
}

// SetCreateTime sets the "create_time" field.
func (m *RegistryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RegistryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RegistryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RegistryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RegistryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RegistryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectUUID sets the "project_uuid" field.
func (m *RegistryMutation) SetProjectUUID(s string) {
	m.project_uuid = &s
}

// ProjectUUID returns the value of the "project_uuid" field in the mutation.
func (m *RegistryMutation) ProjectUUID() (r string, exists bool) {
	v := m.project_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectUUID returns the old "project_uuid" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldProjectUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectUUID: %w", err)
	}
	return oldValue.ProjectUUID, nil
}

// ResetProjectUUID resets all changes to the "project_uuid" field.
func (m *RegistryMutation) ResetProjectUUID() {
	m.project_uuid = nil
}

// SetAuthToken sets the "auth_token" field.
func (m *RegistryMutation) SetAuthToken(s string) {
	m.auth_token = &s
}

// AuthToken returns the value of the "auth_token" field in the mutation.
func (m *RegistryMutation) AuthToken() (r string, exists bool) {
	v := m.auth_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthToken returns the old "auth_token" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldAuthToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthToken: %w", err)
	}
	return oldValue.AuthToken, nil
}

// ClearAuthToken clears the value of the "auth_token" field.
func (m *RegistryMutation) ClearAuthToken() {
	m.auth_token = nil
	m.clearedFields[registry.FieldAuthToken] = struct{}{}
}

// AuthTokenCleared returns if the "auth_token" field was cleared in this mutation.
func (m *RegistryMutation) AuthTokenCleared() bool {
	_, ok := m.clearedFields[registry.FieldAuthToken]
	return ok
}

// ResetAuthToken resets all changes to the "auth_token" field.
func (m *RegistryMutation) ResetAuthToken() {
	m.auth_token = nil
	delete(m.clearedFields, registry.FieldAuthToken)
}

// SetType sets the "type" field.
func (m *RegistryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RegistryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RegistryMutation) ResetType() {
	m._type = nil
}

// SetAPIType sets the "api_type" field.
func (m *RegistryMutation) SetAPIType(s string) {
	m.api_type = &s
}

// APIType returns the value of the "api_type" field in the mutation.
func (m *RegistryMutation) APIType() (r string, exists bool) {
	v := m.api_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIType returns the old "api_type" field's value of the Registry entity.
// If the Registry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistryMutation) OldAPIType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIType: %w", err)
	}
	return oldValue.APIType, nil
}

// ClearAPIType clears the value of the "api_type" field.
func (m *RegistryMutation) ClearAPIType() {
	m.api_type = nil
	m.clearedFields[registry.FieldAPIType] = struct{}{}
}

// APITypeCleared returns if the "api_type" field was cleared in this mutation.
func (m *RegistryMutation) APITypeCleared() bool {
	_, ok := m.clearedFields[registry.FieldAPIType]
	return ok
}

// ResetAPIType resets all changes to the "api_type" field.
func (m *RegistryMutation) ResetAPIType() {
	m.api_type = nil
	delete(m.clearedFields, registry.FieldAPIType)
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *RegistryMutation) AddApplicationIDs(ids ...uint64) {
	if m.applications == nil {
		m.applications = make(map[uint64]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *RegistryMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *RegistryMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *RegistryMutation) RemoveApplicationIDs(ids ...uint64) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *RegistryMutation) RemovedApplicationsIDs() (ids []uint64) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *RegistryMutation) ApplicationsIDs() (ids []uint64) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *RegistryMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddApplicationImageIDs adds the "application_images" edge to the Application entity by ids.
func (m *RegistryMutation) AddApplicationImageIDs(ids ...uint64) {
	if m.application_images == nil {
		m.application_images = make(map[uint64]struct{})
	}
	for i := range ids {
		m.application_images[ids[i]] = struct{}{}
	}
}

// ClearApplicationImages clears the "application_images" edge to the Application entity.
func (m *RegistryMutation) ClearApplicationImages() {
	m.clearedapplication_images = true
}

// ApplicationImagesCleared reports if the "application_images" edge to the Application entity was cleared.
func (m *RegistryMutation) ApplicationImagesCleared() bool {
	return m.clearedapplication_images
}

// RemoveApplicationImageIDs removes the "application_images" edge to the Application entity by IDs.
func (m *RegistryMutation) RemoveApplicationImageIDs(ids ...uint64) {
	if m.removedapplication_images == nil {
		m.removedapplication_images = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.application_images, ids[i])
		m.removedapplication_images[ids[i]] = struct{}{}
	}
}

// RemovedApplicationImages returns the removed IDs of the "application_images" edge to the Application entity.
func (m *RegistryMutation) RemovedApplicationImagesIDs() (ids []uint64) {
	for id := range m.removedapplication_images {
		ids = append(ids, id)
	}
	return
}

// ApplicationImagesIDs returns the "application_images" edge IDs in the mutation.
func (m *RegistryMutation) ApplicationImagesIDs() (ids []uint64) {
	for id := range m.application_images {
		ids = append(ids, id)
	}
	return
}

// ResetApplicationImages resets all changes to the "application_images" edge.
func (m *RegistryMutation) ResetApplicationImages() {
	m.application_images = nil
	m.clearedapplication_images = false
	m.removedapplication_images = nil
}

// Where appends a list predicates to the RegistryMutation builder.
func (m *RegistryMutation) Where(ps ...predicate.Registry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegistryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegistryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Registry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegistryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegistryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Registry).
func (m *RegistryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegistryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, registry.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, registry.FieldDisplayName)
	}
	if m.display_name_lc != nil {
		fields = append(fields, registry.FieldDisplayNameLc)
	}
	if m.description != nil {
		fields = append(fields, registry.FieldDescription)
	}
	if m.create_time != nil {
		fields = append(fields, registry.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, registry.FieldUpdateTime)
	}
	if m.project_uuid != nil {
		fields = append(fields, registry.FieldProjectUUID)
	}
	if m.auth_token != nil {
		fields = append(fields, registry.FieldAuthToken)
	}
	if m._type != nil {
		fields = append(fields, registry.FieldType)
	}
	if m.api_type != nil {
		fields = append(fields, registry.FieldAPIType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegistryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case registry.FieldName:
		return m.Name()
	case registry.FieldDisplayName:
		return m.DisplayName()
	case registry.FieldDisplayNameLc:
		return m.DisplayNameLc()
	case registry.FieldDescription:
		return m.Description()
	case registry.FieldCreateTime:
		return m.CreateTime()
	case registry.FieldUpdateTime:
		return m.UpdateTime()
	case registry.FieldProjectUUID:
		return m.ProjectUUID()
	case registry.FieldAuthToken:
		return m.AuthToken()
	case registry.FieldType:
		return m.GetType()
	case registry.FieldAPIType:
		return m.APIType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegistryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case registry.FieldName:
		return m.OldName(ctx)
	case registry.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case registry.FieldDisplayNameLc:
		return m.OldDisplayNameLc(ctx)
	case registry.FieldDescription:
		return m.OldDescription(ctx)
	case registry.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case registry.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case registry.FieldProjectUUID:
		return m.OldProjectUUID(ctx)
	case registry.FieldAuthToken:
		return m.OldAuthToken(ctx)
	case registry.FieldType:
		return m.OldType(ctx)
	case registry.FieldAPIType:
		return m.OldAPIType(ctx)
	}
	return nil, fmt.Errorf("unknown Registry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case registry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case registry.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case registry.FieldDisplayNameLc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNameLc(v)
		return nil
	case registry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case registry.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case registry.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case registry.FieldProjectUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectUUID(v)
		return nil
	case registry.FieldAuthToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthToken(v)
		return nil
	case registry.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case registry.FieldAPIType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIType(v)
		return nil
	}
	return fmt.Errorf("unknown Registry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegistryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegistryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Registry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegistryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(registry.FieldDisplayName) {
		fields = append(fields, registry.FieldDisplayName)
	}
	if m.FieldCleared(registry.FieldDisplayNameLc) {
		fields = append(fields, registry.FieldDisplayNameLc)
	}
	if m.FieldCleared(registry.FieldDescription) {
		fields = append(fields, registry.FieldDescription)
	}
	if m.FieldCleared(registry.FieldAuthToken) {
		fields = append(fields, registry.FieldAuthToken)
	}
	if m.FieldCleared(registry.FieldAPIType) {
		fields = append(fields, registry.FieldAPIType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegistryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegistryMutation) ClearField(name string) error {
	switch name {
	case registry.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case registry.FieldDisplayNameLc:
		m.ClearDisplayNameLc()
		return nil
	case registry.FieldDescription:
		m.ClearDescription()
		return nil
	case registry.FieldAuthToken:
		m.ClearAuthToken()
		return nil
	case registry.FieldAPIType:
		m.ClearAPIType()
		return nil
	}
	return fmt.Errorf("unknown Registry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegistryMutation) ResetField(name string) error {
	switch name {
	case registry.FieldName:
		m.ResetName()
		return nil
	case registry.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case registry.FieldDisplayNameLc:
		m.ResetDisplayNameLc()
		return nil
	case registry.FieldDescription:
		m.ResetDescription()
		return nil
	case registry.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case registry.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case registry.FieldProjectUUID:
		m.ResetProjectUUID()
		return nil
	case registry.FieldAuthToken:
		m.ResetAuthToken()
		return nil
	case registry.FieldType:
		m.ResetType()
		return nil
	case registry.FieldAPIType:
		m.ResetAPIType()
		return nil
	}
	return fmt.Errorf("unknown Registry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegistryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.applications != nil {
		edges = append(edges, registry.EdgeApplications)
	}
	if m.application_images != nil {
		edges = append(edges, registry.EdgeApplicationImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegistryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case registry.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case registry.EdgeApplicationImages:
		ids := make([]ent.Value, 0, len(m.application_images))
		for id := range m.application_images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegistryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapplications != nil {
		edges = append(edges, registry.EdgeApplications)
	}
	if m.removedapplication_images != nil {
		edges = append(edges, registry.EdgeApplicationImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegistryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case registry.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case registry.EdgeApplicationImages:
		ids := make([]ent.Value, 0, len(m.removedapplication_images))
		for id := range m.removedapplication_images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegistryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapplications {
		edges = append(edges, registry.EdgeApplications)
	}
	if m.clearedapplication_images {
		edges = append(edges, registry.EdgeApplicationImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegistryMutation) EdgeCleared(name string) bool {
	switch name {
	case registry.EdgeApplications:
		return m.clearedapplications
	case registry.EdgeApplicationImages:
		return m.clearedapplication_images
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegistryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Registry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegistryMutation) ResetEdge(name string) error {
	switch name {
	case registry.EdgeApplications:
		m.ResetApplications()
		return nil
	case registry.EdgeApplicationImages:
		m.ResetApplicationImages()
		return nil
	}
	return fmt.Errorf("unknown Registry edge %s", name)
}
